


Q: Given the following code slice:
```
1 static s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)
4 	s32 vps_id;
5 	VVC_VPS *vps;
9 	vps_id = gf_bs_read_int_log(bs, 4, "vps_id");
10 	if (vps_id >= 16) return -1;
11 	if (!vps_id) {
15 	vps = &vvc->vps[vps_id];```
which has a CWE-125 vulnerability at line:
```
15 	vps = &vvc->vps[vps_id];
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning for CWE-125 Patch:

Let's break down the reasoning for the patch addressing the CWE-125 (Out-of-bounds Read) vulnerability.

**Step 1: Vulnerability Analysis:**

* **Potential for Negative Index:** The code reads a value `vps_id` from a bitstream. Importantly, there's no check ensuring that `vps_id` is non-negative after line 9. 
* **Array Access:** The value of `vps_id` is used directly as an index into the `vvc->vps` array on line 15. If `vps_id` is negative, this access will be out-of-bounds, leading to a read from memory outside the allocated array.

**Step 2:  Impact of Out-of-Bounds Read:**

* **Crashes:** Accessing memory outside the array bounds can cause the program to crash (segmentation fault).
* **Unexpected Behavior:** The value read from an out-of-bounds memory location is undefined. This can lead to unpredictable program behavior and potential security vulnerabilities.

**Step 3: Patch Rationale:**

The patch addresses the vulnerability by adding an explicit check for negative values of `vps_id`:

```diff
--- a/gf_media_vvc_read_vps_bs_internal.c
+++ b/gf_media_vvc_read_vps_bs_internal.c
@@ -9,7 +9,7 @@
 5 	VVC_VPS *vps;
 9 	vps_id = gf_bs_read_int_log(bs, 4, "vps_id");
 10 	if (vps_id >= 16) return -1;
---> 	if ((vps_id<0) || (vps_id >= 16)) return -1;
+	if (vps_id < 0 || vps_id >= 16) return -1;
 11 	if (!vps_id) {
 15 	vps = &vvc->vps[vps_id];```

* **Combined Check:**  The patched line `if (vps_id < 0 || vps_id >= 16)` ensures that `vps_id` falls within the valid index range of the `vvc->vps` array (assuming it has a size of 16).
* **Error Handling:**  If `vps_id` is invalid (negative or too large), the function returns `-1`, signaling an error.

**Conclusion:**

By adding a simple bounds check for negative values, the patch effectively prevents the out-of-bounds read vulnerability. This makes the code more robust and secure. 



Q: Given the following code slice:
```
1 static void ecall(mrb_state *mrb, int i)
3     struct RProc *p;
7     p = mrb->c->ensure[i];```
which has a CWE-125 vulnerability at line:
```
7     p = mrb->c->ensure[i];
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning for CWE-125 Patch

Here's a breakdown of the reasoning behind the patch for the CWE-125 (Out-of-bounds Read) vulnerability:

**Step 1: Root Cause Analysis**

- **Understanding the Code:** The code snippet accesses an element within the `mrb->c->ensure` array using the index `i`. 
- **Potential Vulnerability:** The vulnerability arises if the value of `i` is negative or greater than or equal to the size of the `mrb->c->ensure` array. This would lead to reading data from outside the allocated memory for the array.
- **Consequences:** Reading out-of-bounds memory can lead to:
    - **Crashes:**  Accessing invalid memory addresses often results in segmentation faults.
    - **Unpredictable Behavior:** The program might read garbage data, causing unexpected behavior and potentially compromising security.
    - **Information Leakage:** Attackers could exploit out-of-bounds reads to access sensitive information stored in memory adjacent to the array.

**Step 2: Fixing Strategy**

The patch aims to prevent out-of-bounds reads by adding a bounds check:

- **Checking for Negative Index:** The added `if (i < 0)` condition directly addresses the possibility of a negative index. If `i` is negative, the function immediately returns, preventing the out-of-bounds read.
- **Missing Upper Bound Check:**  The patch only addresses the negative index scenario. It does *not* explicitly check if `i` exceeds the upper bound of the `mrb->c->ensure` array. This is a limitation of the provided patch.

**Improved Patch**

A more complete patch should include a check for both the lower and upper bounds of the array:

```c
static void ecall(mrb_state *mrb, int i) {
    struct RObject *exc;
    int ensure_size = sizeof(mrb->c->ensure) / sizeof(mrb->c->ensure[0]); // Calculate array size

    // Check for both negative and out-of-bounds positive indices
    if (i < 0 || i >= ensure_size) {
        return; 
    }

    struct RProc *p = mrb->c->ensure[i];
    // ... rest of the function ... 
}
```

**Explanation of the Improved Patch:**

1. **Calculate Array Size:**  We determine the size of the `mrb->c->ensure` array using `sizeof()` to prevent hardcoding the size. 
2. **Combined Bounds Check:** The `if` condition now checks for both `i < 0` (negative index) and `i >= ensure_size` (index exceeding the upper bound).
3. **Safe Access:**  Only if the index `i` is within the valid range, the code proceeds to access the `mrb->c->ensure[i]` element.

**Key Takeaways:**

- **Bounds Checking is Crucial:** Always validate array indices before accessing array elements to prevent out-of-bounds read vulnerabilities.
- **Thorough Validation:** Check for both negative indices and indices that exceed the upper bound of the array. 
- **Dynamic Size Calculation:** When possible, calculate array sizes dynamically to avoid potential errors from hardcoded values. 



Q: Given the following code slice:
```
1 static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,
2 		unsigned int *rsize)
4 	if (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&
7 		rdesc[105] = rdesc[110] = 0x03;
8 		rdesc[106] = rdesc[111] = 0x21;```
which has a CWE-125 vulnerability at line:
```
8 		rdesc[106] = rdesc[111] = 0x21;
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning Steps for Patching CWE-125 Vulnerability

Here's a breakdown of the reasoning behind the patch:

**Step 1: Root Cause Analysis**

- **Understanding CWE-125:** CWE-125 (Out-of-bounds Read) occurs when the program reads data from outside the bounds of the intended buffer. 
- **Analyzing the Code:**  
    - The code accesses `rdesc[111]`. 
    - The only size check is `*rsize >= 107`. 
    - **Problem:** If `*rsize` is less than 112, accessing `rdesc[111]` will lead to an out-of-bounds read.

**Step 2: Vulnerability Confirmation**

- The vulnerability lies in the conditional statement's insufficient bounds checking.  The code assumes `rdesc` has at least 112 elements based on the accesses within the `if` block.

**Step 3: Fixing Strategy**

- **Ensure Sufficient Size:**  To prevent the out-of-bounds read, the code must ensure that `rdesc` has at least 112 elements before accessing `rdesc[111]`.

**Step 4: Implementing the Patch**

- **Modify the Size Check:** Change the condition `*rsize >= 107` to `*rsize >= 112`. This ensures that `rdesc` is large enough to safely access all the elements referenced within the `if` block.

```diff
--- a/drivers/hid/hid-sensor-hub.c
+++ b/drivers/hid/hid-sensor-hub.c
@@ -33,7 +33,7 @@ static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 
 static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *rsize)
-	if (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&
+	if (*rsize >= 112 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&
 			rdesc[106] == 0x02 && rdesc[109] == 0x02) {
 		rdesc[105] = rdesc[110] = 0x03;
 		rdesc[106] = rdesc[111] = 0x21;

```

**Conclusion**

The patch effectively addresses the CWE-125 vulnerability by strengthening the bounds check, ensuring that the code only accesses elements within the valid range of the `rdesc` array. This prevents potential crashes, unexpected behavior, or security vulnerabilities that could arise from reading data outside the intended memory region. 



Q: Given the following code slice:
```
1 static s32 gf_hevc_read_vps_bs_internal(GF_BitStream *bs, HEVCState *hevc, Bool stop_at_vps_ext)
5 	s32 vps_id;
6 	HEVC_VPS *vps;
10 	vps_id = gf_bs_read_int_log(bs, 4, "vps_id");
12 	if (vps_id >= 16) return -1;
14 	vps = &hevc->vps[vps_id];```
which has a CWE-125 vulnerability at line:
```
14 	vps = &hevc->vps[vps_id];
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning for the Patch in CWE-125 Vulnerability

The code you provided demonstrates a classic example of a potential out-of-bounds read vulnerability (CWE-125) due to insufficient bounds checking on the `vps_id` variable. Let's break down the reasoning behind the patch:

**Step 1: Vulnerability Analysis**

1. **Data Source:** The `vps_id` variable is read from a bitstream (`bs`) using `gf_bs_read_int_log`. This function's behavior and potential return values are crucial. It's likely reading an integer value encoded within the bitstream, but without more context on `gf_bs_read_int_log`, we have to assume it could return any integer value, including negative ones.

2. **Data Usage:** The `vps_id` is then used as an index to access an element in the `hevc->vps` array. The size of this array is not explicitly stated in the code snippet, but the existing check `if (vps_id >= 16)` implies it's likely 16. 

3. **Potential Vulnerability:** The vulnerability arises if `vps_id` is negative. A negative index would lead to accessing memory outside the bounds of the `hevc->vps` array, potentially reading unintended data or even causing a crash.

**Step 2: Patching Strategy**

The current code only checks if `vps_id` is greater than or equal to 16.  To fix the out-of-bounds read vulnerability, we need to add a check to ensure `vps_id` is also not negative:

```diff
--- a/code.c
+++ b/code.c
@@ -10,7 +10,7 @@
 5 	s32 vps_id;
 6 	HEVC_VPS *vps;
 10 	vps_id = gf_bs_read_int_log(bs, 4, "vps_id");
-12 	if (vps_id >= 16) return -1;
+12 	if ((vps_id<0) || (vps_id >= 16)) return -1;
 14 	vps = &hevc->vps[vps_id];
 ```

**Explanation of the Patch:**

* **`(vps_id < 0)`:** This condition explicitly checks if `vps_id` is negative.
* **`(vps_id >= 16)`:** This condition maintains the existing check for exceeding the upper bound of the array.
* **`return -1;`:** If either condition is true, it indicates an invalid `vps_id`, and the function safely returns an error code (-1) to prevent further processing and potential crashes.

**Additional Considerations:**

* **Assumptions:** This analysis assumes the size of `hevc->vps` is 16. If the array size is different, the upper bound check should be adjusted accordingly.
* **Defensive Programming:** It's good practice to include bounds checks even if you believe the data source should theoretically always provide valid values. This helps guard against unforeseen errors or malicious data in the bitstream. 



Q: Given the following code slice:
```
1 static s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)
4 	s32 vps_id;
5 	VVC_VPS *vps;
9 	vps_id = gf_bs_read_int_log(bs, 4, "vps_id");
10 	if (vps_id >= 16) return -1;
11 	if (!vps_id) {
15 	vps = &vvc->vps[vps_id];```
which has a CWE-125 vulnerability at line:
```
15 	vps = &vvc->vps[vps_id];
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning for Patching CWE-125 (Out-of-bounds Read)

Here's a breakdown of the vulnerability and the reasoning behind the patch:

**Step 1: Root Cause Analysis:**

1. **Data Structure and Access:** The code accesses an array `vvc->vps` using the index `vps_id`. The size of the `vvc->vps` array is not explicitly stated, but the code implies it could hold at least 16 elements (indices 0 to 15).

2. **Input Validation:** The code partially validates `vps_id` by checking if it's greater than or equal to 16 (`vps_id >= 16`). If true, it returns -1, likely indicating an error.

3. **Missing Validation:** The crucial missing check is for **negative values** of `vps_id`.  If `vps_id` is negative, accessing `vvc->vps[vps_id]` leads to an out-of-bounds read, accessing memory outside the allocated array.

4. **Potential Vulnerability:** An attacker could potentially manipulate the input data (likely the bitstream `bs`) that determines the value of `vps_id`. Providing a negative value for `vps_id` would allow reading arbitrary memory, potentially leading to information disclosure or crashes.

**Step 2: Fixing Strategy:**

The vulnerability arises due to the missing check for negative values of `vps_id`. 

**The patch addresses this by adding a condition to check for negative values:**

```diff
< 	if (vps_id >= 16) return -1;
---
> 	if ((vps_id<0) || (vps_id >= 16)) return -1;
```

**Reasoning for the Patch:**

* **Complete Bounds Checking:**  By adding `(vps_id < 0)`, the patch ensures that `vps_id` is within the valid index range (0 to 15) for the `vvc->vps` array. 
* **Early Return:** If `vps_id` is negative or greater than or equal to 16, the function returns -1, preventing the out-of-bounds read and potential vulnerabilities. 

**Conclusion:**

The patch effectively mitigates the CWE-125 vulnerability by ensuring that the array index `vps_id` is always within the valid bounds of the `vvc->vps` array, preventing out-of-bounds reads and potential security risks. 



Q: Given the following code slice:
```
1 static int read_private_key(RSA *rsa)
3     int r;
5     sc_file_t *file;
6     const sc_acl_entry_t *e;
8     size_t bufsize, keysize;
9     r = select_app_df();
10     if (r)
15     r = sc_select_file(card, &path, &file);
16     if (r)
21     e = sc_file_get_acl_entry(file, SC_AC_OP_READ);
22     if (e == NULL || e->method == SC_AC_NEVER)
26     bufsize = file->size;```
which has a CWE-125 vulnerability at line:
```
26     bufsize = file->size;
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
A: Here's a breakdown of the reasoning behind the patch for the CWE-125 (Out-of-bounds Read) vulnerability:

**Step 1: Root Cause Analysis**

1. **Data Flow:** The vulnerability arises from the use of `file->size` to determine the size of the buffer `buf`.  The value of `file->size` comes directly from an external source (presumably a smartcard file) without proper validation.

2. **Potential Overflow:** If `file->size` reports a size larger than the actual capacity of the buffer `buf` (determined by `sizeof buf`), a subsequent read operation using `bufsize` could read data beyond the bounds of `buf`.

3. **Consequences:** An out-of-bounds read can lead to:
   - **Crashes:** Attempting to access memory outside the allocated buffer will likely cause a segmentation fault.
   - **Information Disclosure:**  The attacker might be able to read sensitive data adjacent to the buffer in memory. 
   - **Exploitation:** In some cases, carefully crafted out-of-bounds reads can be used to overwrite critical data structures or even execute arbitrary code.

**Step 2: Fixing Strategy**

The core issue is the lack of bounds checking when using an externally provided size.  The fix needs to ensure that `bufsize` never exceeds the actual size of the buffer `buf`.

**The Patch:**

```diff
--- a/vulnerable_code.c
+++ b/vulnerable_code.c
@@ -24,4 +24,4 @@
 22     if (e == NULL || e->method == SC_AC_NEVER)
 26     bufsize = file->size;
 ```
-    bufsize = file->size;
+    bufsize = MIN(file->size, sizeof buf);

```

**Explanation:**

- **`MIN(file->size, sizeof buf)`:**  This code ensures that `bufsize` is assigned the smaller value between the reported file size (`file->size`) and the actual size of the buffer `buf`. 

**Reasoning:**

By using `MIN`, the code guarantees that:

- If `file->size` is smaller than or equal to the buffer size, the entire file content can be safely read.
- If `file->size` is larger than the buffer size, only the data that fits within the buffer will be read, preventing an out-of-bounds read.

**Important Note:** While this patch prevents the out-of-bounds read, it might be necessary to handle cases where the file size exceeds the buffer size differently. This might involve reading the file in chunks or using a dynamically allocated buffer to accommodate the entire file content. The appropriate handling depends on the specific requirements of the application. 



Q: Given the following code slice:
```
1 bit_write_MC (Bit_Chain *dat, BITCODE_MC val)
3   int i, j;
5   unsigned char byte[5];
6   BITCODE_UMC mask = 0x0000007f;
7   BITCODE_UMC value = (BITCODE_UMC)val;
9   if (val < 0)
12       value = (BITCODE_UMC)-val;
14   for (i = 4, j = 0; i >= 0; i--, j += 7)
16       byte[i] = (unsigned char)((value & mask) >> j);
17       byte[i] |= 0x80;
18       mask = mask << 7;
20   for (i = 0; i < 4; i++)
21     if (byte[i] & 0x7f)
24   if (byte[i] & 0x40)```
which has a CWE-125 vulnerability at line:
```
24   if (byte[i] & 0x40)
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning Steps for Patching CWE-125 in the Code Slice

The code slice exhibits a potential CWE-125 vulnerability (Out-of-bounds Read) at line 24. Let's analyze the root cause and devise a patching strategy.

### Step 1: Root Cause Analysis

1. **Loop Iteration and Array Access:** The loop at line 20 iterates through the `byte` array using the index `i` with a range of `0` to `3` (inclusive). This means `byte[i]` accesses elements from `byte[0]` to `byte[3]`.

2. **Conditional Check without Bounds:** Line 24 (`if (byte[i] & 0x40)`) performs a bitwise AND operation between the value at `byte[i]` and `0x40`. However, this check **does not** consider whether `i` is within the valid range of the `byte` array.

3. **Potential Out-of-Bounds Read:** If the code execution reaches line 24 with `i` being less than 0, it will attempt to access `byte[-1]`, which is outside the bounds of the array. This leads to an out-of-bounds read vulnerability, potentially accessing unintended memory locations and causing unpredictable behavior.

### Step 2: Fixing Strategy

The core issue lies in the missing bounds check before accessing `byte[i]` on line 24. To rectify this, we need to ensure that `i` is within the valid range of the `byte` array (0 to 3 inclusive) before performing the bitwise operation.

### Patch Implementation

The patch introduces an additional condition to the `if` statement on line 24:

```diff
--- a/code.c
+++ b/code.c
@@ -22,5 +22,5 @@
 20   for (i = 0; i < 4; i++)
 21     if (byte[i] & 0x7f)
 24-   if (byte[i] & 0x40)
+   if (byte[i] & 0x40 && i > 0)

```

By adding `&& i > 0`, the code now checks if `i` is greater than 0 **before** accessing `byte[i]`. This ensures that the code only proceeds with the bitwise AND operation when `i` points to a valid index within the `byte` array, effectively preventing the out-of-bounds read vulnerability.



Q: Given the following code slice:
```
1 s32 vvc_parse_picture_header(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)
3 	u32 pps_id;
5 	si->irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, "irap_or_gdr_pic");
6 	si->non_ref_pic = gf_bs_read_int_log(bs, 1, "non_ref_pic");
7 	if (si->irap_or_gdr_pic)
8 		si->gdr_pic = gf_bs_read_int_log(bs, 1, "gdr_pic");
9 	if ((si->inter_slice_allowed_flag = gf_bs_read_int_log(bs, 1, "inter_slice_allowed_flag")))
10 		si->intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, "intra_slice_allowed_flag");
12 	pps_id = gf_bs_read_ue_log(bs, "pps_id");
13 	if (pps_id >= 64)
15 	si->pps = &vvc->pps[pps_id];```
which has a CWE-125 vulnerability at line:
```
15 	si->pps = &vvc->pps[pps_id];
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
Let's break down the reasoning behind the patch for this potential CWE-125 (Out-of-bounds Read) vulnerability.

**Step 1: Root Cause Analysis**

- **Data Source:** The value of `pps_id` is read from a bitstream (`bs`) using `gf_bs_read_ue_log(bs, "pps_id")`.  Crucially, there's no guarantee at this point about the range of values `pps_id` might hold. It could be negative or larger than expected.

- **Data Use:**  The value of `pps_id` is used as an index to access an element in the `vvc->pps` array:  `si->pps = &vvc->pps[pps_id];`.

- **Array Size Assumption:** The code seems to assume that `vvc->pps` has at least 64 elements. This assumption is based on the existing check: `if (pps_id >= 64)`.

- **Missing Check:** The code only checks if `pps_id` is greater than or equal to 64. **It fails to check if `pps_id` is negative.**

- **Potential Vulnerability:** If `pps_id` is negative, accessing `vvc->pps[pps_id]` would lead to an out-of-bounds read, potentially accessing memory outside the allocated bounds of the array. This could result in a crash or allow an attacker to read sensitive data.

**Step 2: Fixing Strategy**

- **Complete Bounds Checking:** To prevent the out-of-bounds read, we need to ensure that `pps_id` falls within the valid index range of the `vvc->pps` array. This requires checking for both an upper and lower bound.

- **Patch:** The patch achieves this by adding an additional condition to the `if` statement:

   ```diff
   < 	if (pps_id >= 64)
   ---
   > 	if ((pps_id < 0) || (pps_id >= 64)) 
   ```

   Now, the code checks if `pps_id` is less than 0 **or** greater than or equal to 64. If either condition is true, it means `pps_id` is an invalid index, and the potentially dangerous array access is avoided.

**Key Takeaway**

Always validate data received from external sources (like files or network streams) before using it as an array index. Ensure that index values fall within the defined bounds of your arrays to prevent out-of-bounds read vulnerabilities. 



Q: Given the following code slice:
```
1 int ll_fid2path(struct inode *inode, void __user *arg)
4     const struct getinfo_fid2path __user *gfin = arg;
5     struct getinfo_fid2path *gfout;
6     u32 pathlen;
7     size_t outsize;
9     if (!capable(CFS_CAP_DAC_READ_SEARCH) && !(ll_i2sbi(inode)->ll_flags & LL_SBI_USER_FID2PATH))
13     if (get_user(pathlen, &gfin->gf_pathlen))
17     outsize = sizeof(*gfout) + pathlen;```
which has a CWE-125 vulnerability at line:
```
17     outsize = sizeof(*gfout) + pathlen;
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning for CWE-125 Patch:

Here's a breakdown of the vulnerability and the reasoning behind the patch for the CWE-125 (Out-of-bounds Read) vulnerability:

**Step 1: Root Cause Analysis:**

1. **Untrusted Input:** The variable `pathlen` is read from user space (`get_user(pathlen, &gfin->gf_pathlen)`). This means the value of `pathlen` is controlled by the user and is considered untrusted.

2. **Potential Overflow:** The code calculates `outsize` by adding `sizeof(*gfout)` to `pathlen`. If `pathlen` is excessively large, this addition could lead to an integer overflow. 

3. **Out-of-Bounds Read:** An integer overflow on `outsize` could result in a value smaller than intended.  Later in the code (not shown in the provided snippet), this smaller `outsize` might be used to allocate memory or read data, leading to an out-of-bounds read vulnerability. The code would then be accessing memory outside the intended buffer, potentially exposing sensitive information or causing a crash.

**Step 2: Fixing Strategy:**

1. **Validate Input:** The patch addresses the root cause by adding validation for the `pathlen` input:

   ```c++
   if (pathlen > PATH_MAX) {
       return -EINVAL;
   }
   ```

2. **Safe Calculation:**  This validation ensures that `pathlen` is within a safe range (less than or equal to `PATH_MAX`, which is a system-defined maximum path length). By validating the input, the patch prevents the integer overflow and subsequent out-of-bounds read.

**Conclusion:**

The patch effectively mitigates the CWE-125 vulnerability by:

* **Validating untrusted input:** It checks if `pathlen` exceeds the maximum allowed path length.
* **Preventing integer overflow:** By validating the input, the code ensures that the calculation of `outsize` does not overflow.
* **Avoiding out-of-bounds read:**  Preventing the overflow ensures that memory allocation and reads based on `outsize` remain within safe and intended bounds. 
