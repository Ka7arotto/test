


Q: Given the following code slice:
```
1 static s32 gf_hevc_read_vps_bs_internal(GF_BitStream *bs, HEVCState *hevc, Bool stop_at_vps_ext)
5 	s32 vps_id;
6 	HEVC_VPS *vps;
10 	vps_id = gf_bs_read_int_log(bs, 4, "vps_id");
12 	if (vps_id >= 16) return -1;
14 	vps = &hevc->vps[vps_id];```
which has a CWE-125 vulnerability at line:
```
14 	vps = &hevc->vps[vps_id];
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning for the Patch in CWE-125 Vulnerability

The code you provided demonstrates a classic example of a potential out-of-bounds read vulnerability (CWE-125) due to insufficient bounds checking on the `vps_id` variable. Let's break down the reasoning behind the patch:

**Step 1: Vulnerability Analysis**

1. **Data Source:** The `vps_id` variable is read from a bitstream (`bs`) using `gf_bs_read_int_log`. This function's behavior and potential return values are crucial. It's likely reading an integer value encoded within the bitstream, but without more context on `gf_bs_read_int_log`, we have to assume it could return any integer value, including negative ones.

2. **Data Usage:** The `vps_id` is then used as an index to access an element in the `hevc->vps` array. The size of this array is not explicitly stated in the code snippet, but the existing check `if (vps_id >= 16)` implies it's likely 16. 

3. **Potential Vulnerability:** The vulnerability arises if `vps_id` is negative. A negative index would lead to accessing memory outside the bounds of the `hevc->vps` array, potentially reading unintended data or even causing a crash.

**Step 2: Patching Strategy**

The current code only checks if `vps_id` is greater than or equal to 16.  To fix the out-of-bounds read vulnerability, we need to add a check to ensure `vps_id` is also not negative:

```diff
--- a/code.c
+++ b/code.c
@@ -10,7 +10,7 @@
 5 	s32 vps_id;
 6 	HEVC_VPS *vps;
 10 	vps_id = gf_bs_read_int_log(bs, 4, "vps_id");
-12 	if (vps_id >= 16) return -1;
+12 	if ((vps_id<0) || (vps_id >= 16)) return -1;
 14 	vps = &hevc->vps[vps_id];
 ```

**Explanation of the Patch:**

* **`(vps_id < 0)`:** This condition explicitly checks if `vps_id` is negative.
* **`(vps_id >= 16)`:** This condition maintains the existing check for exceeding the upper bound of the array.
* **`return -1;`:** If either condition is true, it indicates an invalid `vps_id`, and the function safely returns an error code (-1) to prevent further processing and potential crashes.

**Additional Considerations:**

* **Assumptions:** This analysis assumes the size of `hevc->vps` is 16. If the array size is different, the upper bound check should be adjusted accordingly.
* **Defensive Programming:** It's good practice to include bounds checks even if you believe the data source should theoretically always provide valid values. This helps guard against unforeseen errors or malicious data in the bitstream. 



Q: Given the following code slice:
```
1 static s32 gf_hevc_read_sps_bs_internal(GF_BitStream *bs, HEVCState *hevc, u8 layer_id, u32 *vui_flag_pos)
6 	HEVC_VPS *vps;
14 	vps_id = gf_bs_read_int_log(bs, 4, "vps_id");
15 	if (vps_id >= 16) {
31 	sps_id = gf_bs_read_ue_log(bs, "sps_id");
32 	if ((sps_id < 0) || (sps_id >= 16)) {
43 	vps = &hevc->vps[vps_id];```
which has a CWE-125 vulnerability at line:
```
43 	vps = &hevc->vps[vps_id];
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning for CWE-125 Patch

The original code has a potential out-of-bounds read vulnerability (CWE-125) because it only checks if `vps_id` is greater than or equal to 16, but not if it's less than 0.

Here's a breakdown of the reasoning:

**Step 1: Identify the Vulnerable Assumption**

The code assumes that `vps_id` will always be a non-negative value. It relies on the check `if (vps_id >= 16)` to catch potential out-of-bounds accesses. However, it fails to consider the possibility of `vps_id` being negative.

**Step 2: Understand the Potential Consequence**

If `vps_id` is negative, accessing `hevc->vps[vps_id]` will lead to an out-of-bounds read. This is because negative indices in C/C++ don't automatically wrap around to the end of the array; they typically access memory locations before the start of the array, leading to undefined behavior.

**Step 3: Implement the Fix**

The patch addresses the issue by adding a check for negative values of `vps_id`. The modified condition:

```c
if ((vps_id < 0) || (vps_id >= 16))
```

ensures that `vps_id` falls within the valid range of indices for the `hevc->vps` array (assuming it has a size of 16 or less, which should be verified separately). 

By checking for both negative and excessively large values of `vps_id`, the patched code prevents out-of-bounds reads and improves the robustness of the program.



Q: Given the following code slice:
```
1 static s32 gf_media_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc)
4 	s32 pps_id;
5 	VVC_PPS *pps;
8 	pps_id = gf_bs_read_int_log(bs, 6, "pps_id");
10 	if ((pps_id < 0) || (pps_id >= 64)) {
14 	pps = &vvc->pps[pps_id];
16 	if (!pps->state) {
17 		pps->id = pps_id;
18 		pps->state = 1;
20 	pps->sps_id = gf_bs_read_int_log(bs, 4, "sps_id");
21 	if (pps->sps_id >= 16) {```
which has a CWE-125 vulnerability at line:
```
21 	if (pps->sps_id >= 16) {
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning Steps for Generating Patch for CWE-125

Here's a breakdown of the reasoning behind the patch for the CWE-125 (Out-of-bounds Read) vulnerability:

**Step 1: Identify the Vulnerability**

- **Line 21:** The code checks if `pps->sps_id` is greater than or equal to 16 (`pps->sps_id >= 16`).
- **Potential Problem:** The code doesn't check if `pps->sps_id` is **negative**. A negative index could lead to reading data from memory locations before the start of the intended data structure, causing a buffer overread vulnerability.

**Step 2: Root Cause Analysis**

- **Data Origin:** The value of `pps->sps_id` is read from a bitstream (`gf_bs_read_int_log`) on line 20.
- **Missing Check:** There's no explicit check to ensure the read value from the bitstream falls within a safe and valid range (in this case, likely 0 to 15 inclusive).
- **Assumption:**  The code implicitly assumes that `pps->sps_id` will always be non-negative. This assumption might not hold true in all situations, especially when dealing with external data sources.

**Step 3: Patch Strategy**

- **Bounds Checking:** The core issue is the missing lower bounds check. We need to ensure `pps->sps_id` is within the valid range (likely 0-15) before using it as an index.
- **Solution:** Add an additional check to ensure `pps->sps_id` is not negative (`pps->sps_id >= 0`).

**Step 4: Patch Implementation**

The patch modifies the conditional statement on line 21 to include the missing lower bounds check:

```diff
--- a/gf_media_vvc_read_pps_bs_internal.c
+++ b/gf_media_vvc_read_pps_bs_internal.c
@@ -20,5 +20,5 @@
 18 		pps->state = 1;
 20 	pps->sps_id = gf_bs_read_int_log(bs, 4, "sps_id");
 21 	if (pps->sps_id >= 16) {
---> 	if ((pps->sps_id<0) || (pps->sps_id >= 16)) {

```

**Explanation:**

- The patched code now explicitly checks if `pps->sps_id` is less than 0 (`pps->sps_id < 0`). 
- If `pps->sps_id` is negative, the conditional statement evaluates to true, and the code likely handles the error, preventing the out-of-bounds read.

**Result:** 

By adding the lower bounds check, the patch prevents potential out-of-bounds reads caused by negative index values, enhancing the security and robustness of the code. 



Q: Given the following code slice:
```
1 static s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)
4 	s32 vps_id;
5 	VVC_VPS *vps;
9 	vps_id = gf_bs_read_int_log(bs, 4, "vps_id");
10 	if (vps_id >= 16) return -1;
11 	if (!vps_id) {
15 	vps = &vvc->vps[vps_id];```
which has a CWE-125 vulnerability at line:
```
15 	vps = &vvc->vps[vps_id];
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning for Patching CWE-125 (Out-of-bounds Read)

Here's a breakdown of the vulnerability and the reasoning behind the patch:

**Step 1: Root Cause Analysis:**

1. **Data Structure and Access:** The code accesses an array `vvc->vps` using the index `vps_id`. The size of the `vvc->vps` array is not explicitly stated, but the code implies it could hold at least 16 elements (indices 0 to 15).

2. **Input Validation:** The code partially validates `vps_id` by checking if it's greater than or equal to 16 (`vps_id >= 16`). If true, it returns -1, likely indicating an error.

3. **Missing Validation:** The crucial missing check is for **negative values** of `vps_id`.  If `vps_id` is negative, accessing `vvc->vps[vps_id]` leads to an out-of-bounds read, accessing memory outside the allocated array.

4. **Potential Vulnerability:** An attacker could potentially manipulate the input data (likely the bitstream `bs`) that determines the value of `vps_id`. Providing a negative value for `vps_id` would allow reading arbitrary memory, potentially leading to information disclosure or crashes.

**Step 2: Fixing Strategy:**

The vulnerability arises due to the missing check for negative values of `vps_id`. 

**The patch addresses this by adding a condition to check for negative values:**

```diff
< 	if (vps_id >= 16) return -1;
---
> 	if ((vps_id<0) || (vps_id >= 16)) return -1;
```

**Reasoning for the Patch:**

* **Complete Bounds Checking:**  By adding `(vps_id < 0)`, the patch ensures that `vps_id` is within the valid index range (0 to 15) for the `vvc->vps` array. 
* **Early Return:** If `vps_id` is negative or greater than or equal to 16, the function returns -1, preventing the out-of-bounds read and potential vulnerabilities. 

**Conclusion:**

The patch effectively mitigates the CWE-125 vulnerability by ensuring that the array index `vps_id` is always within the valid bounds of the `vvc->vps` array, preventing out-of-bounds reads and potential security risks. 



Q: Given the following code slice:
```
1 decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)
3 	size_t cipher_len;
4 	size_t i;
6 	unsigned char plaintext[4096] = { 0 };
9 	if (!card->drv_data) 
15 	if (in[0] == 0x99)
19 	if (0x01 == in[2] && 0x82 != in[1]) {
20 		cipher_len = in[1];
21 		i = 3;
23 	else if (0x01 == in[3] && 0x81 == in[1]) {
24 		cipher_len = in[2];
25 		i = 4;
27 	else if (0x01 == in[4] && 0x82 == in[1]) {
28 		cipher_len = in[2] * 0x100;
29 		cipher_len += in[3];
30 		i = 5;
36 	if (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)
46 	while (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))
47 		cipher_len--;
49 	if (2 == cipher_len)
53 	*out_len = cipher_len - 2;```
which has a CWE-125 vulnerability at line:
```
53 	*out_len = cipher_len - 2;
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning for Patching CWE-125 in `decrypt_response` Function

Here's a breakdown of the vulnerability, the patch, and the reasoning behind it:

**Step 1: Vulnerability Analysis (CWE-125: Out-of-bounds Read)**

The code has a potential out-of-bounds read vulnerability at line 53:

```c
*out_len = cipher_len - 2;
```

Here's why:

1. **Uncontrolled Data Flow:** The value of `cipher_len` is derived from the input buffer `in` through various conditional checks (lines 15-30).  This means an attacker could potentially manipulate the contents of `in` to influence the value of `cipher_len`.
2. **Lack of Bounds Check:** There is no guarantee that `cipher_len - 2` will result in a value that's within the bounds of the memory allocated for the output (`out`). If `cipher_len` is less than 2, the calculation will result in a negative value, leading to an out-of-bounds read when `*out_len` is dereferenced.

**Step 2: Patching Strategy**

The patch addresses this vulnerability by adding an additional condition to the `if` statement:

```diff
--- a/decrypt_response
+++ b/decrypt_response
@@ -50,5 +50,5 @@
 46 	while (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))
 47 		cipher_len--;
 49 	if (2 == cipher_len)
-53 	*out_len = cipher_len - 2;```
+53 	if (2 == cipher_len || *out_len < cipher_len - 2)
+```

**Step 3: Reasoning**

* **Preventing Negative Values:** The added condition `*out_len < cipher_len - 2` prevents the assignment when `cipher_len - 2` would result in a negative value. This ensures that `*out_len` is never set to a value that could cause an out-of-bounds read.
* **Ensuring Valid Output Length:** By checking if `*out_len` is less than `cipher_len - 2`, the patch guarantees that the output buffer is large enough to hold the decrypted data. This prevents potential buffer overflows when writing the decrypted data to the output buffer.

**In essence, the patch introduces a crucial bounds check, ensuring that the calculated output length (`cipher_len - 2`) is both non-negative and within the valid range of the output buffer pointed to by `out_len`. This prevents potential out-of-bounds read vulnerabilities and makes the code more robust.** 



Q: Given the following code slice:
```
1 static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,
2 		unsigned int *rsize)
4 	if (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&
7 		rdesc[105] = rdesc[110] = 0x03;
8 		rdesc[106] = rdesc[111] = 0x21;```
which has a CWE-125 vulnerability at line:
```
8 		rdesc[106] = rdesc[111] = 0x21;
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning Steps for Patching CWE-125 Vulnerability

Here's a breakdown of the reasoning behind the patch:

**Step 1: Root Cause Analysis**

- **Understanding CWE-125:** CWE-125 (Out-of-bounds Read) occurs when the program reads data from outside the bounds of the intended buffer. 
- **Analyzing the Code:**  
    - The code accesses `rdesc[111]`. 
    - The only size check is `*rsize >= 107`. 
    - **Problem:** If `*rsize` is less than 112, accessing `rdesc[111]` will lead to an out-of-bounds read.

**Step 2: Vulnerability Confirmation**

- The vulnerability lies in the conditional statement's insufficient bounds checking.  The code assumes `rdesc` has at least 112 elements based on the accesses within the `if` block.

**Step 3: Fixing Strategy**

- **Ensure Sufficient Size:**  To prevent the out-of-bounds read, the code must ensure that `rdesc` has at least 112 elements before accessing `rdesc[111]`.

**Step 4: Implementing the Patch**

- **Modify the Size Check:** Change the condition `*rsize >= 107` to `*rsize >= 112`. This ensures that `rdesc` is large enough to safely access all the elements referenced within the `if` block.

```diff
--- a/drivers/hid/hid-sensor-hub.c
+++ b/drivers/hid/hid-sensor-hub.c
@@ -33,7 +33,7 @@ static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 
 static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *rsize)
-	if (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&
+	if (*rsize >= 112 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&
 			rdesc[106] == 0x02 && rdesc[109] == 0x02) {
 		rdesc[105] = rdesc[110] = 0x03;
 		rdesc[106] = rdesc[111] = 0x21;

```

**Conclusion**

The patch effectively addresses the CWE-125 vulnerability by strengthening the bounds check, ensuring that the code only accesses elements within the valid range of the `rdesc` array. This prevents potential crashes, unexpected behavior, or security vulnerabilities that could arise from reading data outside the intended memory region. 



Q: Given the following code slice:
```
1 s32 vvc_parse_picture_header(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)
3 	u32 pps_id;
5 	si->irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, "irap_or_gdr_pic");
6 	si->non_ref_pic = gf_bs_read_int_log(bs, 1, "non_ref_pic");
7 	if (si->irap_or_gdr_pic)
8 		si->gdr_pic = gf_bs_read_int_log(bs, 1, "gdr_pic");
9 	if ((si->inter_slice_allowed_flag = gf_bs_read_int_log(bs, 1, "inter_slice_allowed_flag")))
10 		si->intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, "intra_slice_allowed_flag");
12 	pps_id = gf_bs_read_ue_log(bs, "pps_id");
13 	if (pps_id >= 64)
15 	si->pps = &vvc->pps[pps_id];```
which has a CWE-125 vulnerability at line:
```
15 	si->pps = &vvc->pps[pps_id];
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
Let's break down the reasoning for this patch.

**Step 1: Root Cause Analysis**

- **Data Flow:** The vulnerability stems from the variable `pps_id`. It's read from a bitstream using `gf_bs_read_ue_log(bs, "pps_id")`.  Critically, we don't have immediate guarantees about the potential values of `pps_id` after this read operation.
- **Array Indexing:**  The value of `pps_id` is then used as an index into the `vvc->pps` array.  
- **Missing Bounds Check:** The original code only checks if `pps_id` is greater than or equal to 64. This leaves a crucial gap: what if `pps_id` is negative?  A negative index would lead to accessing memory *before* the start of the `vvc->pps` array, resulting in a classic out-of-bounds read vulnerability (CWE-125).

**Step 2: Fixing Strategy**

To prevent the out-of-bounds read, we need a more comprehensive bounds check:

1. **Lower Bound:** Ensure `pps_id` is not negative (`pps_id >= 0`).
2. **Upper Bound:** Ensure `pps_id` is less than the size of the `vvc->pps` array. Assuming the array has a fixed size of 64, this check remains as `pps_id < 64`.

**The Patch Explained**

```diff
< 	if (pps_id >= 64)
---
> 	if ((pps_id < 0) || (pps_id >= 64)) 
```

The patch addresses the vulnerability by adding the essential lower bound check (`pps_id < 0`). Now, the code only proceeds to access `vvc->pps[pps_id]` if `pps_id` falls within the valid index range of the array (0 to 63 inclusive).

**Key Takeaway**

Always be cautious when using external data, especially values read from files or network streams, to index arrays or buffers. Robust bounds checking is essential to prevent out-of-bounds memory access vulnerabilities. 



Q: Given the following code slice:
```
1 static s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext)
4 	s32 vps_id;
5 	VVC_VPS *vps;
9 	vps_id = gf_bs_read_int_log(bs, 4, "vps_id");
10 	if (vps_id >= 16) return -1;
11 	if (!vps_id) {
15 	vps = &vvc->vps[vps_id];```
which has a CWE-125 vulnerability at line:
```
15 	vps = &vvc->vps[vps_id];
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning for CWE-125 Patch:

Let's break down the reasoning for the patch addressing the CWE-125 (Out-of-bounds Read) vulnerability.

**Step 1: Vulnerability Analysis:**

* **Potential for Negative Index:** The code reads a value `vps_id` from a bitstream. Importantly, there's no check ensuring that `vps_id` is non-negative after line 9. 
* **Array Access:** The value of `vps_id` is used directly as an index into the `vvc->vps` array on line 15. If `vps_id` is negative, this access will be out-of-bounds, leading to a read from memory outside the allocated array.

**Step 2:  Impact of Out-of-Bounds Read:**

* **Crashes:** Accessing memory outside the array bounds can cause the program to crash (segmentation fault).
* **Unexpected Behavior:** The value read from an out-of-bounds memory location is undefined. This can lead to unpredictable program behavior and potential security vulnerabilities.

**Step 3: Patch Rationale:**

The patch addresses the vulnerability by adding an explicit check for negative values of `vps_id`:

```diff
--- a/gf_media_vvc_read_vps_bs_internal.c
+++ b/gf_media_vvc_read_vps_bs_internal.c
@@ -9,7 +9,7 @@
 5 	VVC_VPS *vps;
 9 	vps_id = gf_bs_read_int_log(bs, 4, "vps_id");
 10 	if (vps_id >= 16) return -1;
---> 	if ((vps_id<0) || (vps_id >= 16)) return -1;
+	if (vps_id < 0 || vps_id >= 16) return -1;
 11 	if (!vps_id) {
 15 	vps = &vvc->vps[vps_id];```

* **Combined Check:**  The patched line `if (vps_id < 0 || vps_id >= 16)` ensures that `vps_id` falls within the valid index range of the `vvc->vps` array (assuming it has a size of 16).
* **Error Handling:**  If `vps_id` is invalid (negative or too large), the function returns `-1`, signaling an error.

**Conclusion:**

By adding a simple bounds check for negative values, the patch effectively prevents the out-of-bounds read vulnerability. This makes the code more robust and secure. 



Q: Given the following code slice:
```
1 static void ecall(mrb_state *mrb, int i)
3     struct RProc *p;
7     p = mrb->c->ensure[i];```
which has a CWE-125 vulnerability at line:
```
7     p = mrb->c->ensure[i];
```
Please generate the patch for the vulnerability. Please follow the patch format in the exemplars.
## Reasoning for CWE-125 Patch

Here's a breakdown of the reasoning behind the patch for the CWE-125 (Out-of-bounds Read) vulnerability:

**Step 1: Root Cause Analysis**

- **Understanding the Code:** The code snippet accesses an element within the `mrb->c->ensure` array using the index `i`. 
- **Potential Vulnerability:** The vulnerability arises if the value of `i` is negative or greater than or equal to the size of the `mrb->c->ensure` array. This would lead to reading data from outside the allocated memory for the array.
- **Consequences:** Reading out-of-bounds memory can lead to:
    - **Crashes:**  Accessing invalid memory addresses often results in segmentation faults.
    - **Unpredictable Behavior:** The program might read garbage data, causing unexpected behavior and potentially compromising security.
    - **Information Leakage:** Attackers could exploit out-of-bounds reads to access sensitive information stored in memory adjacent to the array.

**Step 2: Fixing Strategy**

The patch aims to prevent out-of-bounds reads by adding a bounds check:

- **Checking for Negative Index:** The added `if (i < 0)` condition directly addresses the possibility of a negative index. If `i` is negative, the function immediately returns, preventing the out-of-bounds read.
- **Missing Upper Bound Check:**  The patch only addresses the negative index scenario. It does *not* explicitly check if `i` exceeds the upper bound of the `mrb->c->ensure` array. This is a limitation of the provided patch.

**Improved Patch**

A more complete patch should include a check for both the lower and upper bounds of the array:

```c
static void ecall(mrb_state *mrb, int i) {
    struct RObject *exc;
    int ensure_size = sizeof(mrb->c->ensure) / sizeof(mrb->c->ensure[0]); // Calculate array size

    // Check for both negative and out-of-bounds positive indices
    if (i < 0 || i >= ensure_size) {
        return; 
    }

    struct RProc *p = mrb->c->ensure[i];
    // ... rest of the function ... 
}
```

**Explanation of the Improved Patch:**

1. **Calculate Array Size:**  We determine the size of the `mrb->c->ensure` array using `sizeof()` to prevent hardcoding the size. 
2. **Combined Bounds Check:** The `if` condition now checks for both `i < 0` (negative index) and `i >= ensure_size` (index exceeding the upper bound).
3. **Safe Access:**  Only if the index `i` is within the valid range, the code proceeds to access the `mrb->c->ensure[i]` element.

**Key Takeaways:**

- **Bounds Checking is Crucial:** Always validate array indices before accessing array elements to prevent out-of-bounds read vulnerabilities.
- **Thorough Validation:** Check for both negative indices and indices that exceed the upper bound of the array. 
- **Dynamic Size Calculation:** When possible, calculate array sizes dynamically to avoid potential errors from hardcoded values. 
