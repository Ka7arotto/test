c
// ... in the vmbus_channel struct ...
    atomic_t ringbuffer_page_refcount;

// ... initialization ...
    atomic_set(&channel->ringbuffer_page_refcount, 0); // Initialize to 0


static inline void free_the_page(struct page *page, unsigned int order) {
    if (pcp_allowed_order(order) && page != NULL && atomic_dec_and_test(&page->refcount) ) { // Decrement and check refcount of page struct
        free_unref_page(page, order);
    }
}


void vmbus_free_ring(struct vmbus_channel *channel) {
    // ...

    if (channel->ringbuffer_page) {
        atomic_inc(&channel->ringbuffer_page->refcount); // Increment refcount before use, assuming refcount field now exists in page struct
        hv_ringbuffer_cleanup(&channel->outbound); // free_the_page now handles refcount decrement.
        hv_ringbuffer_cleanup(&channel->inbound);

        if(atomic_dec_and_test(&channel->ringbuffer_page->refcount)) {  // Decrement refcount after cleanup
           __free_pages(channel->ringbuffer_page, get_order(channel->ringbuffer_pagecount << PAGE_SHIFT));
        }
        channel->ringbuffer_page = NULL; 
    }
}
