c
struct vma_list_node {
    struct vm_area_struct *vma;
    struct list_head list;
};

LIST_HEAD(vmas_to_remove);


prev = NULL;
for_each_vma(vmi, vma) { // ... existing loop ...
    // ... same checks as before

    bool removed = false;
    prev = vma_merge(...);

    if (vmi.vma == NULL) { // The VMA was merged away
      struct vma_list_node *n = kmalloc(sizeof(*n), GFP_KERNEL);
      if (n) {
          n->vma = vma;
          list_add(&n->list, &vmas_to_remove);
          removed = true;
      } else { // Handle allocation failure
          // ... error handling ...
      }
    }

    if (!removed) {
      vma = vmi.vma; // Continue if it wasn't merged/removed.
      // ... Existing code to work with the potentially modified vma
    }
} // End of vma loop


// Remove VMAs outside of the loop
struct vma_list_node *n, *tmp;
list_for_each_entry_safe(n, tmp, &vmas_to_remove, list) {
    list_del(&n->list);
    kfree(n);  // Free the node
    // No need to explicitly free the vma; vma_merge already handled it.
}
