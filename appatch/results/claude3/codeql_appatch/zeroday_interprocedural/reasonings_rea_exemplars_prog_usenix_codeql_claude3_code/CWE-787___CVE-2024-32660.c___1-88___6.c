1 int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,
2                     UINT32* pDstSize, UINT32 flags)
4 	int status = -1;
5 	BYTE descriptor = 0;
6 	wStream sbuffer = { 0 };
7 	wStream* stream = Stream_StaticConstInit(&sbuffer, pSrcData, SrcSize);
9 	WINPR_ASSERT(zgfx);
10 	WINPR_ASSERT(stream);
12 	if (!Stream_CheckAndLogRequiredLength(TAG, stream, 1))
13 		goto fail;
15 	Stream_Read_UINT8(stream, descriptor); /* descriptor (1 byte) */
17 	if (descriptor == ZGFX_SEGMENTED_SINGLE)
19 		if (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))
20 			goto fail;
24 		if (zgfx->OutputCount > 0)
27 		if (!*ppDstData)
28 			goto fail;
31 		CopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);
33 	else if (descriptor == ZGFX_SEGMENTED_MULTIPART)
35 		UINT32 segmentSize = 0;
36 		UINT16 segmentNumber = 0;
37 		UINT16 segmentCount = 0;
38 		UINT32 uncompressedSize = 0;
39 		BYTE* pConcatenated = NULL;
40 		size_t used = 0;
42 		if (!Stream_CheckAndLogRequiredLength(TAG, stream, 6))
43 			goto fail;
45 		Stream_Read_UINT16(stream, segmentCount);     /* segmentCount (2 bytes) */
46 		Stream_Read_UINT32(stream, uncompressedSize); /* uncompressedSize (4 bytes) */
48 		if (!Stream_CheckAndLogRequiredLengthOfSize(TAG, stream, segmentCount, sizeof(UINT32)))
49 			goto fail;
51 		pConcatenated = aligned_zgfx_malloc(uncompressedSize);
53 		if (!pConcatenated)
54 			goto fail;