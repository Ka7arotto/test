1 static long qxl_fence_wait(struct dma_fence *fence, bool intr,
2 			   signed long timeout)
4 	struct qxl_device *qdev;
5 	struct qxl_release *release;
6 	int count = 0, sc = 0;
7 	bool have_drawable_releases;
8 	unsigned long cur, end = jiffies + timeout;
10 	qdev = container_of(fence->lock, struct qxl_device, release_lock);
11 	release = container_of(fence, struct qxl_release, base);
12 	have_drawable_releases = release->type == QXL_RELEASE_DRAWABLE;
14 retry:
15 	sc++;
17 	if (dma_fence_is_signaled(fence))
18 		goto signaled;
20 	qxl_io_notify_oom(qdev);
22 	for (count = 0; count < 11; count++) {
23 		if (!qxl_queue_garbage_collect(qdev, true))
24 			break;
26 		if (dma_fence_is_signaled(fence))
27 			goto signaled;
30 	if (dma_fence_is_signaled(fence))
31 		goto signaled;
33 	if (have_drawable_releases || sc < 4) {
34 		if (sc > 2)
36 			usleep_range(500, 1000);
38 		if (time_after(jiffies, end))
39 			return 0;
41 		if (have_drawable_releases && sc > 300) {
42 			DMA_FENCE_WARN(fence,