1 static BOOL rdp_redirection_read_base64_wchar(UINT32 flag, wStream* s, UINT32* pLength,
2                                               BYTE** pData)
4 	BOOL rc = FALSE;
5 	char buffer[64] = { 0 };
6 	const BYTE* ptr = NULL;
8 	if (!rdp_redirection_get_data(s, pLength, &ptr))
9 		return FALSE;
10 	const WCHAR* wchar = (const WCHAR*)ptr;
12 	size_t utf8_len = 0;
13 	char* utf8 = ConvertWCharNToUtf8Alloc(wchar, *pLength, &utf8_len);
14 	if (!utf8)
15 		goto fail;
17 	redirection_free_data(pData, NULL);
19 	utf8_len = strnlen(utf8, utf8_len);
21 	if (!*pData)
22 		goto fail;
24 	size_t rlen = utf8_len;
25 	size_t wpos = 0;
26 	char* tok = strtok(utf8, "\r\n");
27 	while (tok)
29 		const size_t len = strnlen(tok, rlen);
30 		rlen -= len;
32 		size_t bplen = 0;
33 		BYTE* bptr = NULL;
34 		crypto_base64_decode(tok, len, &bptr, &bplen);
35 		if (!bptr)
36 			goto fail;
37 		memcpy(&(*pData)[wpos], bptr, bplen);
38 		wpos += bplen;
39 		free(bptr);
41 		tok = strtok(NULL, "\r\n");
45 	WLog_DBG(TAG, "%s:", rdp_redirection_flags_to_string(flag, buffer, sizeof(buffer)));
47 	rc = TRUE;
48 fail:
49 	if (!rc)
50 		WLog_ERR(TAG, "failed to read base64 data");
51 	free(utf8);