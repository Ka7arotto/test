1 static int __vmbus_establish_gpadl(struct vmbus_channel *channel,
2 				   enum hv_gpadl_type type, void *kbuffer,
3 				   u32 size, u32 send_offset,
4 				   struct vmbus_gpadl *gpadl)
6 	struct vmbus_channel_gpadl_header *gpadlmsg;
7 	struct vmbus_channel_gpadl_body *gpadl_body;
8 	struct vmbus_channel_msginfo *msginfo = NULL;
9 	struct vmbus_channel_msginfo *submsginfo, *tmp;
10 	struct list_head *curr;
11 	u32 next_gpadl_handle;
12 	unsigned long flags;
13 	int ret = 0;
15 	next_gpadl_handle =
16 		(atomic_inc_return(&vmbus_connection.next_gpadl_handle) - 1);
18 	ret = create_gpadl_header(type, kbuffer, size, send_offset, &msginfo);
19 	if (ret)
20 		return ret;
22 	ret = set_memory_decrypted((unsigned long)kbuffer,
23 				   PFN_UP(size));
24 	if (ret) {
25 		dev_warn(&channel->device_obj->device,
26 			 "Failed to set host visibility for new GPADL %d.\n",
27 			 ret);
28 		return ret;
31 	init_completion(&msginfo->waitevent);
32 	msginfo->waiting_channel = channel;
34 	gpadlmsg = (struct vmbus_channel_gpadl_header *)msginfo->msg;
35 	gpadlmsg->header.msgtype = CHANNELMSG_GPADL_HEADER;
36 	gpadlmsg->child_relid = channel->offermsg.child_relid;
37 	gpadlmsg->gpadl = next_gpadl_handle;
40 	spin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);
41 	list_add_tail(&msginfo->msglistentry,
42 		      &vmbus_connection.chn_msg_list);
44 	spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);
46 	if (channel->rescind) {
47 		ret = -ENODEV;
48 		goto cleanup;
51 	ret = vmbus_post_msg(gpadlmsg, msginfo->msgsize -
52 			     sizeof(*msginfo), true);
54 	trace_vmbus_establish_gpadl_header(gpadlmsg, ret);
56 	if (ret != 0)
57 		goto cleanup;
59 	list_for_each(curr, &msginfo->submsglist) {
60 		submsginfo = (struct vmbus_channel_msginfo *)curr;
61 		gpadl_body =
62 			(struct vmbus_channel_gpadl_body *)submsginfo->msg;
64 		gpadl_body->header.msgtype =
65 			CHANNELMSG_GPADL_BODY;
66 		gpadl_body->gpadl = next_gpadl_handle;
68 		ret = vmbus_post_msg(gpadl_body,
69 				     submsginfo->msgsize - sizeof(*submsginfo),
70 				     true);
72 		trace_vmbus_establish_gpadl_body(gpadl_body, ret);
74 		if (ret != 0)
75 			goto cleanup;
78 	wait_for_completion(&msginfo->waitevent);
80 	if (msginfo->response.gpadl_created.creation_status != 0) {
81 		pr_err("Failed to establish GPADL: err = 0x%x\n",
82 		       msginfo->response.gpadl_created.creation_status);
84 		ret = -EDQUOT;
85 		goto cleanup;
88 	if (channel->rescind) {
89 		ret = -ENODEV;
90 		goto cleanup;
94 	gpadl->gpadl_handle = gpadlmsg->gpadl;
95 	gpadl->buffer = kbuffer;
96 	gpadl->size = size;
99 cleanup:
100 	spin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);
101 	list_del(&msginfo->msglistentry);
102 	spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);