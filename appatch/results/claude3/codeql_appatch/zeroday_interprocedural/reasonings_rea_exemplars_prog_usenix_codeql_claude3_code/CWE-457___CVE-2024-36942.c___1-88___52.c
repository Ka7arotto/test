1 static int qca_download_firmware(struct hci_dev *hdev,
2 				 struct qca_fw_config *config,
3 				 enum qca_btsoc_type soc_type,
4 				 u8 rom_ver)
6 	const struct firmware *fw;
7 	u8 *data;
8 	const u8 *segment;
9 	int ret, size, remain, i = 0;
11 	bt_dev_info(hdev, "QCA Downloading %s", config->fwname);
13 	ret = request_firmware(&fw, config->fwname, &hdev->dev);
14 	if (ret) {
18 		if (soc_type == QCA_WCN6750 && config->type == ELF_TYPE_PATCH) {
19 			bt_dev_dbg(hdev, "QCA Failed to request file: %s (%d)",
20 				   config->fwname, ret);
21 			config->type = TLV_TYPE_PATCH;
22 			snprintf(config->fwname, sizeof(config->fwname),
23 				 "qca/msbtfw%02x.tlv", rom_ver);
24 			bt_dev_info(hdev, "QCA Downloading %s", config->fwname);
25 			ret = request_firmware(&fw, config->fwname, &hdev->dev);
26 			if (ret) {
27 				bt_dev_err(hdev, "QCA Failed to request file: %s (%d)",
28 					   config->fwname, ret);
29 				return ret;
32 			bt_dev_err(hdev, "QCA Failed to request file: %s (%d)",
33 				   config->fwname, ret);
34 			return ret;
38 	size = fw->size;
39 	data = vmalloc(fw->size);
40 	if (!data) {
41 		bt_dev_err(hdev, "QCA Failed to allocate memory for file: %s",
42 			   config->fwname);
43 		release_firmware(fw);
44 		return -ENOMEM;
47 	memcpy(data, fw->data, size);
48 	release_firmware(fw);
50 	ret = qca_tlv_check_data(hdev, config, data, size, soc_type);
51 	if (ret)
52 		return ret;
54 	segment = data;
55 	remain = size;
56 	while (remain > 0) {
57 		int segsize = min(MAX_SIZE_PER_TLV_SEGMENT, remain);
59 		bt_dev_dbg(hdev, "Send segment %d, size %d", i++, segsize);
61 		remain -= segsize;
63 		if (!remain || segsize < MAX_SIZE_PER_TLV_SEGMENT)
64 			config->dnld_mode = QCA_SKIP_EVT_NONE;
66 		ret = qca_tlv_send_segment(hdev, segsize, segment,
67 					   config->dnld_mode, soc_type);
68 		if (ret)
69 			goto out;
71 		segment += segsize;
80 	if (config->dnld_type == QCA_SKIP_EVT_VSE_CC ||
81 	    config->dnld_type == QCA_SKIP_EVT_VSE)
82 		ret = qca_inject_cmd_complete_event(hdev);
84 out:
85 	vfree(data);