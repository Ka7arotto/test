1 static ssize_t rvu_dbg_qsize_write(struct file *filp,
2 				   const char __user *buffer, size_t count,
3 				   loff_t *ppos, int blktype)
5 	char *blk_string = (blktype == BLKTYPE_NPA) ? "npa" : "nix";
6 	struct seq_file *seqfile = filp->private_data;
7 	char *cmd_buf, *cmd_buf_tmp, *subtoken;
8 	struct rvu *rvu = seqfile->private;
9 	struct dentry *current_dir;
10 	int blkaddr;
11 	u16 pcifunc;
12 	int ret, lf;
14 	cmd_buf = memdup_user(buffer, count + 1);
15 	if (IS_ERR(cmd_buf))
16 		return -ENOMEM;
18 	cmd_buf[count] = '\0';
20 	cmd_buf_tmp = strchr(cmd_buf, '\n');
21 	if (cmd_buf_tmp) {
23 		count = cmd_buf_tmp - cmd_buf + 1;
26 	cmd_buf_tmp = cmd_buf;
27 	subtoken = strsep(&cmd_buf, " ");
28 	ret = subtoken ? kstrtoint(subtoken, 10, &lf) : -EINVAL;
29 	if (cmd_buf)
30 		ret = -EINVAL;
32 	if (ret < 0 || !strncmp(subtoken, "help", 4)) {
33 		dev_info(rvu->dev, "Use echo <%s-lf > qsize\n", blk_string);
34 		goto qsize_write_done;
37 	if (blktype == BLKTYPE_NPA) {
38 		blkaddr = BLKADDR_NPA;
40 		current_dir = filp->f_path.dentry->d_parent;
41 		blkaddr = (!strcmp(current_dir->d_name.name, "nix1") ?
42 				   BLKADDR_NIX1 : BLKADDR_NIX0);
45 	if (!rvu_dbg_is_valid_lf(rvu, blkaddr, lf, &pcifunc)) {
46 		ret = -EINVAL;
47 		goto qsize_write_done;
49 	if (blktype  == BLKTYPE_NPA)
50 		rvu->rvu_dbg.npa_qsize_id = lf;
51 	else
52 		rvu->rvu_dbg.nix_qsize_id = lf;
54 qsize_write_done:
55 	kfree(cmd_buf_tmp);