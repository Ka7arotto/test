1 SSIZE_T ConvertUtf8NToWChar(const char* str, size_t len, WCHAR* wstr, size_t wlen)
3 	size_t ilen = strnlen(str, len);
4 	BOOL isNullTerminated = FALSE;
5 	if (len == 0)
6 		return 0;
8 	WINPR_ASSERT(str);
10 	if ((len > INT32_MAX) || (wlen > INT32_MAX))
12 		SetLastError(ERROR_INVALID_PARAMETER);
13 		return -1;
15 	if (ilen < len)
17 		isNullTerminated = TRUE;
18 		ilen++;
21 	const int iwlen = (int)wlen;
22 	const int rc = MultiByteToWideChar(CP_UTF8, 0, str, (int)ilen, wstr, iwlen);
23 	if ((rc <= 0) || ((wlen > 0) && (rc > iwlen)))
24 		return -1;
25 	if (!isNullTerminated)
27 		if (wstr && (rc < iwlen))
28 			wstr[rc] = '\0';
29 		return rc;
31 	else if (rc == iwlen)
33 		if (wstr && (wstr[rc - 1] != '\0'))
34 			return rc;
36 	return rc - 1;

873 SSIZE_T Stream_Write_UTF16_String_From_UTF8(wStream* s, size_t dlen, const char* src, size_t length,
874                                             BOOL fill)
876 	WCHAR* str = Stream_PointerAs(s, WCHAR);
878 	if (length == 0)
879 		return 0;
881 	if (!Stream_CheckAndLogRequiredCapacityOfSize(STREAM_TAG, s, dlen, sizeof(WCHAR)))
882 		return -1;
884 	SSIZE_T rc = ConvertUtf8NToWChar(src, length, str, dlen);


895 static BOOL rdp_write_logon_info_v1(wStream* s, logon_info* info)
897 	const size_t charLen = 52 / sizeof(WCHAR);
898 	const size_t userCharLen = 512 / sizeof(WCHAR);
900 	size_t sz = 4 + 52 + 4 + 512 + 4;
901 	size_t len = 0;
903 	if (!Stream_EnsureRemainingCapacity(s, sz))
904 		return FALSE;
907 	WINPR_ASSERT(info);
909 	len = strnlen(info->domain, charLen + 1);
910 	if (len > charLen)
911 		return FALSE;
913 	Stream_Write_UINT32(s, len * sizeof(WCHAR));
914 	if (Stream_Write_UTF16_String_From_UTF8(s, charLen, info->domain, len, TRUE) < 0)
