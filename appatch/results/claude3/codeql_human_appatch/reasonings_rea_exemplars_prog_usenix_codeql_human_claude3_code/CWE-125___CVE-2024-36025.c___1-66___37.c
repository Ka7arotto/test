1 static int32_t
2 qla_edif_app_getstats(scsi_qla_host_t *vha, struct bsg_job *bsg_job)
4 	int32_t			rval = 0;
5 	struct fc_bsg_reply	*bsg_reply = bsg_job->reply;
6 	uint32_t size;
8 	struct app_sinfo_req	app_req;
9 	struct app_stats_reply	*app_reply;
10 	uint32_t pcnt = 0;
12 	sg_copy_to_buffer(bsg_job->request_payload.sg_list,
13 	    bsg_job->request_payload.sg_cnt, &app_req,
14 	    sizeof(struct app_sinfo_req));
15 	if (app_req.num_ports == 0) {
16 		ql_dbg(ql_dbg_async, vha, 0x911d,
17 		   "%s app did not indicate number of ports to return\n",
18 		    __func__);
19 		SET_DID_STATUS(bsg_reply->result, DID_ERROR);
20 		rval = -1;
23 	size = sizeof(struct app_stats_reply) +
24 	    (sizeof(struct app_sinfo) * app_req.num_ports);
26 	app_reply = kzalloc(size, GFP_KERNEL);
27 	if (!app_reply) {
28 		SET_DID_STATUS(bsg_reply->result, DID_ERROR);
29 		rval = -1;
31 		struct fc_port	*fcport = NULL, *tf;
33 		app_reply->version = EDIF_VERSION1;
35 		list_for_each_entry_safe(fcport, tf, &vha->vp_fcports, list) {
36 			if (fcport->edif.enable) {
37 				if (pcnt > app_req.num_ports)
38 					break;
40 				app_reply->elem[pcnt].rekey_count =
41 				    fcport->edif.rekey_cnt;
42 				app_reply->elem[pcnt].tx_bytes =
43 				    fcport->edif.tx_bytes;
44 				app_reply->elem[pcnt].rx_bytes =
45 				    fcport->edif.rx_bytes;
47 				memcpy(app_reply->elem[pcnt].remote_wwpn,
48 				    fcport->port_name, 8);
50 				pcnt++;
53 		app_reply->elem_count = pcnt;
54 		SET_DID_STATUS(bsg_reply->result, DID_OK);
57 	bsg_job->reply_len = sizeof(struct fc_bsg_reply);
58 	bsg_reply->reply_payload_rcv_len =
59 	    sg_copy_from_buffer(bsg_job->reply_payload.sg_list,
60 	       bsg_job->reply_payload.sg_cnt, app_reply,
61 	       sizeof(struct app_stats_reply) + (sizeof(struct app_sinfo) * pcnt));
63 	kfree(app_reply);