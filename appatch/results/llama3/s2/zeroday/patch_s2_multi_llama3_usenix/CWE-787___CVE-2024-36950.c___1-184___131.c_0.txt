Here are five possible code completions for the given function:

**Completion 1: Reset Bus and Update Generation**
```c
static void bus_reset_work(struct work_struct *work)
{
    struct fw_ohci *ohci =
        container_of(work, struct fw_ohci, bus_reset_work);
    int self_id_count, generation, new_generation, i, j;
    u32 reg;
    void *free_rom = NULL;
    dma_addr_t free_rom_bus = 0;
    bool is_new_root;

    /* Reset bus */
    fw_ohci_reset_bus(ohci);

    /* Update generation */
    new_generation = ohci->generation + 1;
    ohci->generation = new_generation;

    /* Update self_id_count */
    self_id_count = 0;
    for (i = 0; i < ohci->num_ports; i++) {
        if (ohci->ports[i].self_id_valid) {
            self_id_count++;
        }
    }
    ohci->self_id_count = self_id_count;
}
```

**Completion 2: Allocate and Initialize Free ROM**
```c
static void bus_reset_work(struct work_struct *work)
{
    struct fw_ohci *ohci =
        container_of(work, struct fw_ohci, bus_reset_work);
    int self_id_count, generation, new_generation, i, j;
    u32 reg;
    void *free_rom = NULL;
    dma_addr_t free_rom_bus = 0;
    bool is_new_root;

    /* Allocate free ROM */
    free_rom = dma_alloc_coherent(ohci->dev, ohci->free_rom_size, &free_rom_bus, GFP_KERNEL);
    if (!free_rom) {
        dev_err(ohci->dev, "Failed to allocate free ROM\n");
        return;
    }

    /* Initialize free ROM */
    memset(free_rom, 0, ohci->free_rom_size);
    for (i = 0; i < ohci->num_ports; i++) {
        if (ohci->ports[i].self_id_valid) {
            /* Initialize self_id */
            ohci->ports[i].self_id = i;
        }
    }
}
```

**Completion 3: Update Self-IDs and Generation**
```c
static void bus_reset_work(struct work_struct *work)
{
    struct fw_ohci *ohci =
        container_of(work, struct fw_ohci, bus_reset_work);
    int self_id_count, generation, new_generation, i, j;
    u32 reg;
    void *free_rom = NULL;
    dma_addr_t free_rom_bus = 0;
    bool is_new_root;

    /* Update self-IDs */
    for (i = 0; i < ohci->num_ports; i++) {
        if (ohci->ports[i].self_id_valid) {
            ohci->ports[i].self_id = i;
        }
    }

    /* Update generation */
    new_generation = ohci->generation + 1;
    ohci->generation = new_generation;

    /* Update self_id_count */
    self_id_count = 0;
    for (i = 0; i < ohci->num_ports; i++) {
        if (ohci->ports[i].self_id_valid) {
            self_id_count++;
        }
    }
    ohci->self_id_count = self_id_count;
}
```

**Completion 4: Check for New Root Node**
```c
static void bus_reset_work(struct work_struct *work)
{
    struct fw_ohci *ohci =
        container_of(work, struct fw_ohci, bus_reset_work);
    int self_id_count, generation, new_generation, i, j;
    u32 reg;
    void *free_rom = NULL;
    dma_addr_t free_rom_bus = 0;
    bool is_new_root;

    /* Check for new root node */
    is_new_root = false;
    for (i = 0; i < ohci->num_ports; i++) {
        if (ohci->ports[i].self_id_valid && ohci->ports[i].self_id == 0) {
            is_new_root = true;
            break;
        }
    }

    if (is_new_root) {
        /* Update generation */
        new_generation = ohci->generation + 1;
        ohci->generation = new_generation;

        /* Update self_id_count */
        self_id_count = 0;
        for (i = 0; i < ohci->num_ports; i++) {
            if (ohci->ports[i].self_id_valid) {
                self_id_count++;
            }
        }
        ohci->self_id_count = self_id_count;
    }
}
```

**Completion 5: Reset Bus and Update Registers**
```c
static void bus_reset_work(struct work_struct *work)
{
    struct fw_ohci *ohci =
        container_of(work, struct fw_ohci, bus_reset_work);
    int self_id_count, generation, new_generation, i, j;
    u32 reg;
    void *free_rom = NULL;
    dma_addr_t free_rom_bus = 0;
    bool is_new_root;

    /* Reset bus */
    fw_ohci_reset_bus(ohci);

    /* Update registers */
    reg = readl(ohci->regs + OHCI_REG_COMMAND_STATUS);
    reg &= ~OHCI_REG_COMMAND_STATUS_RESET;
    writel(reg, ohci->regs + OHCI_REG_COMMAND_STATUS);

    /* Update generation */
    new_generation = ohci->generation + 1;
    ohci->generation = new_generation;

    /* Update self_id_count */
    self_id_count = 0;
    for (i = 0; i < ohci->num_ports; i++) {
        if (ohci->ports[i].self_id_valid) {
            self_id_count++;
        }
    }
    ohci->self_id_count = self_id_count;
}
```