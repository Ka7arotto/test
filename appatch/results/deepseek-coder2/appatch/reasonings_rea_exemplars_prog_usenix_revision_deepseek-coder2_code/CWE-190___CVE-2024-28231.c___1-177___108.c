1 bool MessageReceiver::proc_Submsg_Data(
2         CDRMessage_t* msg,
3         SubmessageHeader_t* smh,
10     if (smh->submessageLength < RTPSMESSAGE_DATA_MIN_LENGTH)
16     bool endiannessFlag = (smh->flags & BIT(0)) != 0;
17     bool inlineQosFlag = (smh->flags & BIT(1)) != 0;
18     bool dataFlag = (smh->flags & BIT(2)) != 0;
19     bool keyFlag = (smh->flags & BIT(3)) != 0;
20     if (keyFlag && dataFlag)
27     if (endiannessFlag)
29         msg->msg_endian = LITTLEEND;
33         msg->msg_endian = BIGEND;
37     msg->pos += 2;
39     bool valid = true;
40     int16_t octetsToInlineQos = 0;
41     valid &= CDRMessage::readInt16(msg, &octetsToInlineQos); //it should be 16 in this implementation
44     RTPSReader* first_reader = nullptr;
45     EntityId_t readerID;
46     valid &= CDRMessage::readEntityId(msg, &readerID);
49     if (!willAReaderAcceptMsgDirectedTo(readerID, first_reader))
56     CacheChange_t ch;
57     ch.kind = ALIVE;
58     ch.writerGUID.guidPrefix = source_guid_prefix_;
59     valid &= CDRMessage::readEntityId(msg, &ch.writerGUID.entityId);
64     valid &= CDRMessage::readSequenceNumber(msg, &ch.sequenceNumber);
66     if (!valid)
71     if (ch.sequenceNumber <= SequenceNumber_t())
78     if (octetsToInlineQos > RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG)
80         msg->pos += (octetsToInlineQos - RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG);
81         if (msg->pos > msg->length)
89     uint32_t inlineQosSize = 0;
91     if (inlineQosFlag)
93         if (!ParameterList::updateCacheChangeFromInlineQos(ch, msg, inlineQosSize))
105     if (dataFlag || keyFlag)
107         uint32_t payload_size;
108         payload_size = smh->submessageLength -