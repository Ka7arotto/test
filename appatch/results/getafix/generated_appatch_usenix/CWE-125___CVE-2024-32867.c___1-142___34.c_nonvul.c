static Packet * Defrag4Reassemble ( ThreadVars * tv , DefragTracker * tracker , Packet * p ) { Packet * rp = NULL ; /* Should not be here unless we have seen the last fragment. */ if ( ! tracker -> seen_last ) { return NULL ; } /* Check that we have the first fragment and its of a valid size. */ Frag * first = RB_MIN ( IP_FRAGMENTS , & tracker -> fragment_tree ) ; if ( first == NULL ) { done } if ( first -> offset != 0 ) { /* Still waiting for the first fragment. */ done } if ( first -> len < sizeof ( IPV4Hdr ) ) { /* First fragment isn't enough for an IPv6 header. */ error_remove_tracker } /* Check that we have all the data. Relies on the fact } fragments are inserted in frag_offset order. */ SCFree all the resources held by this tracker. */ doesn't overlap. We're done. */ first packet.  All fragment offsets are relative to* this. */ fragments, still continue. The next fragment may have the* same offset with data that is For example, This is due to not all fragments being completely but relying on the copy ordering. */ 