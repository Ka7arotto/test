static ssize_t rvu_dbg_qsize_write ( struct file * filp , const char __user * buffer , size_t count , loff_t * ppos , int blktype ) { char * blk_string = ( blktype == BLKTYPE_NPA ) ?"npa" : "nix" ; struct seq_file * seqfile = filp -> private_data ; char * cmd_buf , * cmd_buf_tmp , * subtoken ; struct rvu * rvu = seqfile -> private ; struct dentry * current_dir ; int blkaddr ; u16 pcifunc ; long ret , lf ; cmd_buf = memdup_user ( buffer , count + 1 ) ; if ( IS_ERR ( cmd_buf ) ) { return - ENOMEM ; } cmd_buf [ count ] = '\0' ; cmd_buf_tmp = strchr ( cmd_buf , '\n' ) ; if ( cmd_buf_tmp ) { * cmd_buf_tmp = '\0' ; count = cmd_buf_tmp - cmd_buf + 1 ; } cmd_buf_tmp = cmd_buf ; subtoken = strsep ( & cmd_buf , " " ) ; ret = subtoken ?kstrtoint ( subtoken , 10 , & lf ) : - EINVAL ; if ( cmd_buf ) { ret = - EINVAL ; } if ( ret < 0 || ! strncmp ( subtoken , "help" , 4 ) ) { dev_info ( rvu -> dev , "Use echo<%s-lf>qsize\n" , blk_string ) ; qsize_write_done } if ( blktype == BLKTYPE_NPA ) { blkaddr = BLKADDR_NPA ; } else { current_dir = filp -> f_path . dentry -> d_parent ; blkaddr = ( ! strcmp ( current_dir -> d_name . name , "nix1" ) ?BLKADDR_NIX1 : BLKADDR_NIX0 ) ; } if ( ! rvu_dbg_is_valid_lf ( rvu , blkaddr , lf , & pcifunc ) ) { ret = - EINVAL ; qsize_write_done } if ( blktype == BLKTYPE_NPA ) { rvu -> rvu_dbg . npa_qsize_id = lf ; } else { rvu -> rvu_dbg . nix_qsize_id = lf ; } qsize_write_done kfree ( cmd_buf_tmp ) ; return ret ?ret : count ; } 