Base64Ecode DecodeBase64 ( uint8_t * dest , uint32_t dest_size , const uint8_t * src , uint32_t len , uint32_t * consumed_bytes , uint32_t * decoded_bytes , Base64Mode mode ) { size_t val ; uint32_t padding = 0 , bbidx = 0 , sp = 0 , leading_sp = 0 ; uint8_t * dptr = dest ; uint8_t b64 [ B64_BLOCK ] { 0 0 0 0 } ; ; bool valid = true ; Base64Ecode ecode = BASE64_ECODE_OK ; * decoded_bytes = 0 ; /* Traverse through each alpha-numeric letter in the source array */ for ( uint32_t i = 0 ; i < len ; i ++ ) { /* Get decimal representation */ val = GetBase64Value ( src [ i ] ) ; if ( val < 0 ) { if ( mode == BASE64_MODE_RFC2045 && src [ i ] != '=' ) { if ( bbidx == 0 ) { /* Special case where last block of data has a leading space or invalid char */ leading_sp ++ ; } sp ++ ; continue ; } /* Invalid character found, so decoding fails */ if ( src [ i ] != '=' ) { valid = false ; ecode = BASE64_ECODE_ERR ; if ( mode == BASE64_MODE_STRICT ) { * decoded_bytes = 0 ; } break ; } padding ++ ; } /* For each alpha-numeric letter in the source array, find the } } value */ buffer overflow while decoding, so, return and let the caller take care of the* remaining bytes to be decoded which should always be<4 at this stage */ 