static void xmlParseEndTag2 ( xmlParserCtxtPtr ctxt , const xmlChar * prefix , const xmlChar * URI , int line , int nsNr , int tlen ) { const xmlChar * name ; GROW ; if ( ( RAW != '<' ) || ( NXT ( 1 ) != '/' ) ) { xmlFatalErr ( ctxt , XML_ERR_LTSLASH_REQUIRED , NULL ) ; return ; } SKIP ( 2 ) ; curLength = ctxt -> input -> end - ctxt -> input -> cur ; if ( ( tlen > 0 ) && ( curLength >= ( size_t ) tlen ) && ( xmlStrncmp ( ctxt -> input -> cur , ctxt -> name , tlen ) == 0 ) ) { if ( ( curLength >= ( size_t ) ( tlen + 1 ) ) && ( ctxt -> input -> cur [ tlen ] == '>' ) ) { ctxt -> input -> cur += tlen + 1 ; ctxt -> input -> col += tlen + 1 ; done } ctxt -> input -> cur += tlen ; ctxt -> input -> col += tlen ; name = ( xmlChar * ) 1 ; } else { if ( prefix == NULL ) { name = xmlParseNameAndCompare ( ctxt , ctxt -> name ) ; } else { name = xmlParseQNameAndCompare ( ctxt , ctxt -> name , prefix ) ; } }   } We should definitely be at the ending "S? '>'" [ WFC: Element Type Match ]* The Name in an element's end-tag must match the element type in SAX: End of Tag*/ 