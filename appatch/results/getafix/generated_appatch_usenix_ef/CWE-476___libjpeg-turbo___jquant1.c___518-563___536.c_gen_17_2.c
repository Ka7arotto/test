quantize_ord_dither ( , , , ) /* General case, with ordered dithering */ { my_cquantize_ptr cquantize = ( my_cquantize_ptr ) cinfo -> cquantize ; register JSAMPROW input_ptr ; register JSAMPROW output_ptr ; JSAMPROW colorindex_ci ; int * dither ; /* points to active row of dither matrix */ int row_index , col_index ; /* current indexes into dither matrix */ int nc = cinfo -> out_color_components ; unsigned int ci ; int row ; JDIMENSION col ; JDIMENSION width = cinfo -> output_width ; for ( row = 0 ; row < num_rows ; row ++ ) { /* Initialize output values to 0 so can process components separately */ jzero_far ( ( void * ) output_buf [ row ] , ( size_t ) ( width * sizeof ( JSAMPLE ) ) ) ; row_index = cquantize -> row_index ; for ( ci = 0 ; ci < nc ; ci ++ ) { input_ptr = input_buf [ row ] + ci ; output_ptr = output_buf [ row ] ; colorindex_ci = cquantize -> colorindex [ ci ] ; dither = cquantize -> odither [ ci ] [ row_index ] ; col_index = 0 ; for ( col = width ; col > 0 ; col -- ) { /* Form pixel value + dither, range-limit to } } } select output value, accumulate into output code for this pixel.* Range-limiting need not be done explicitly, as we have the colorindex table to produce the right answers for out-of-range* inputs.  The maximum dither is +- MAXJSAMPLE; this sets required amount of padding.*/ } 