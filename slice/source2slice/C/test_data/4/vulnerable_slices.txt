CWE-787___libtiff___tools___thumbnail.c___532-557___552.c_vul.c
1 static void
2 setImage1(const uint8* br, uint32 rw, uint32 rh)
4     int step = rh;
5     int limit = tnh;
6     int err = 0;
7     int bpr = TIFFhowmany8(rw);
8     int sy = 0;
10     uint32 dy;
11     for (dy = 0; dy < tnh; dy++) {
12 	const uint8* rows[256];
13 	uint32 nrows = 1;
15 	rows[0] = br + bpr*sy;
16 	err += step;
17 	while (err >= limit) {
18 	    err -= limit;
19 	    sy++;
20 	    if (err >= limit)
21 		rows[nrows++] = br + bpr*sy;

====================
CWE-369___libtiff___libtiff___tif_ojpeg.c___802-855___816.c_vul.c
1 static int
2 OJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc)
5 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
15 	if (cc%sp->bytes_per_line!=0)

====================
CWE-476___libxml2___valid.c___1158-1222___1181.c_vul.c
1 static void
2 xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob) {
3     if (content == NULL) return;
6     switch (content->type) {
18 	    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||

====================
CWE-787___libtiff___tools___tiff2ps.c___2433-2494___2477.c_vul.c
1 void
2 PSDataColorContig(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)
4 	uint32 row;
6 	int es = samplesperpixel - nc;
7 	tsize_t cc;
8 	unsigned char *tf_buf;
9 	unsigned char *cp, c;
11 	tf_buf = (unsigned char *) _TIFFmalloc(tf_bytesperrow);
12 	if (tf_buf == NULL) {
16 	for (row = 0; row < h; row++) {
17 		if (TIFFReadScanline(tif, tf_buf, row, 0) < 0)
19 		cp = tf_buf;
27 		if (alpha) {
48 			cc = 0;
49 			for (; cc < tf_bytesperrow; cc += samplesperpixel) {
51 				switch (nc) {
52 				case 4: c = *cp++; PUTHEX(c,fd);
53 				case 3: c = *cp++; PUTHEX(c,fd);
54 				case 2: c = *cp++; PUTHEX(c,fd);
55 				case 1: c = *cp++; PUTHEX(c,fd);
57 				cp += es;

====================
CWE-125___coreutils_EF26___src___make-prime-list.c___171-227___214.c_vul.c
1 int
2 main (int argc, char **argv)
4   int limit;
6   char *sieve;
7   size_t size, i;
12   if (argc != 2)
18   limit = atoi (argv[1]);
19   if (limit < 3)
23   if ( !(limit & 1))
24     limit--;
26   size = (limit-1)/2;
28   sieve = xalloc (size);
29   memset (sieve, 1, size);
34   for (i = 0; i < size;)
36       unsigned p = 3+2*i;
37       unsigned j;
41       for (j = (p*p - 3)/2; j < size; j+= p)
42         sieve[j] = 0;
44       while (i < size && sieve[++i] == 0)

====================
CWE-369___libtiff___tools___rgb2ycbcr.c___70-138___100.c_vul.c
1 int
2 main(int argc, char* argv[])
5 	int c;
8 	extern char *optarg;
11 	while ((c = getopt(argc, argv, "c:h:r:v:z")) != -1)
12 		switch (c) {
28 			horizSubSampling = atoi(optarg);

====================
CWE-369___binutils-gdb_EF13___bfd___dwarf2.c___2033-2484___2441.c_vul.c
1 static struct line_info_table*
2 decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)
4   bfd *abfd = unit->abfd;
5   struct line_info_table* table;
6   bfd_byte *line_ptr;
7   bfd_byte *line_end;
8   struct line_head lh;
9   unsigned int i, bytes_read, offset_size;
10   char *cur_file, *cur_dir;
11   unsigned char op_code, extended_op, adj_opcode;
12   unsigned int exop_len;
13   bfd_size_type amt;
15   if (! read_section (abfd, &stash->debug_sections[debug_line],
20   amt = sizeof (struct line_info_table);
21   table = (struct line_info_table *) bfd_alloc (abfd, amt);
22   if (table == NULL)
24   table->abfd = abfd;
25   table->comp_dir = unit->comp_dir;
27   table->num_files = 0;
28   table->files = NULL;
30   table->num_dirs = 0;
31   table->dirs = NULL;
33   table->num_sequences = 0;
34   table->sequences = NULL;
36   table->lcl_head = NULL;
38   if (stash->dwarf_line_size < 16)
46   line_ptr = stash->dwarf_line_buffer + unit->line_offset;
47   line_end = stash->dwarf_line_buffer + stash->dwarf_line_size;
50   lh.total_length = read_4_bytes (abfd, line_ptr, line_end);
51   line_ptr += 4;
52   offset_size = 4;
53   if (lh.total_length == 0xffffffff)
55       lh.total_length = read_8_bytes (abfd, line_ptr, line_end);
56       line_ptr += 8;
57       offset_size = 8;
59   else if (lh.total_length == 0 && unit->addr_size == 8)
62       lh.total_length = read_4_bytes (abfd, line_ptr, line_end);
63       line_ptr += 4;
64       offset_size = 8;
67   if (lh.total_length > (size_t) (line_end - line_ptr))
78   line_end = line_ptr + lh.total_length;
80   lh.version = read_2_bytes (abfd, line_ptr, line_end);
81   if (lh.version < 2 || lh.version > 5)
88   line_ptr += 2;
90   if (line_ptr + offset_size + (lh.version >= 5 ? 8 : (lh.version >= 4 ? 6 : 5))
99   if (lh.version >= 5)
101       unsigned int segment_selector_size;
105       line_ptr += 1;
107       segment_selector_size = read_1_byte (abfd, line_ptr, line_end);
108       line_ptr += 1;
109       if (segment_selector_size != 0)
119   if (offset_size == 4)
120     lh.prologue_length = read_4_bytes (abfd, line_ptr, line_end);
122     lh.prologue_length = read_8_bytes (abfd, line_ptr, line_end);
123   line_ptr += offset_size;
125   lh.minimum_instruction_length = read_1_byte (abfd, line_ptr, line_end);
126   line_ptr += 1;
128   if (lh.version >= 4)
130       lh.maximum_ops_per_insn = read_1_byte (abfd, line_ptr, line_end);
131       line_ptr += 1;
134     lh.maximum_ops_per_insn = 1;
136   if (lh.maximum_ops_per_insn == 0)
144   lh.default_is_stmt = read_1_byte (abfd, line_ptr, line_end);
145   line_ptr += 1;
147   lh.line_base = read_1_signed_byte (abfd, line_ptr, line_end);
148   line_ptr += 1;
150   lh.line_range = read_1_byte (abfd, line_ptr, line_end);
151   line_ptr += 1;
153   lh.opcode_base = read_1_byte (abfd, line_ptr, line_end);
154   line_ptr += 1;
156   if (line_ptr + (lh.opcode_base - 1) >= line_end)
163   amt = lh.opcode_base * sizeof (unsigned char);
164   lh.standard_opcode_lengths = (unsigned char *) bfd_alloc (abfd, amt);
166   lh.standard_opcode_lengths[0] = 1;
168   for (i = 1; i < lh.opcode_base; ++i)
170       lh.standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr, line_end);
171       line_ptr += 1;
174   if (lh.version >= 5)
177       if (!read_formatted_entries (unit, &line_ptr, line_end, table,
182       if (!read_formatted_entries (unit, &line_ptr, line_end, table,
189       while ((cur_dir = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)
191 	  line_ptr += bytes_read;
193 	  if (!line_info_add_include_dir (table, cur_dir))
197       line_ptr += bytes_read;
200       while ((cur_file = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)
202 	  unsigned int dir, xtime, size;
204 	  line_ptr += bytes_read;
206 	  dir = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
207 	  line_ptr += bytes_read;
208 	  xtime = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
209 	  line_ptr += bytes_read;
210 	  size = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);
211 	  line_ptr += bytes_read;
213 	  if (!line_info_add_file_name (table, cur_file, dir, xtime, size))
217       line_ptr += bytes_read;
221   while (line_ptr < line_end)
224       bfd_vma address = 0;
225       unsigned char op_index = 0;
226       char * filename = table->num_files ? concat_filename (table, 1) : NULL;
227       unsigned int line = 1;
228       unsigned int column = 0;
229       unsigned int discriminator = 0;
231       int end_sequence = 0;
237       bfd_vma low_pc  = (bfd_vma) -1;
238       bfd_vma high_pc = 0;
241       while (! end_sequence)
243 	  op_code = read_1_byte (abfd, line_ptr, line_end);
244 	  line_ptr += 1;
246 	  if (op_code >= lh.opcode_base)
249 	      adj_opcode = op_code - lh.opcode_base;
250 	      if (lh.line_range == 0)
252 	      if (lh.maximum_ops_per_insn == 1)
253 		address += (adj_opcode / lh.line_range
257 		  address += ((op_index + adj_opcode / lh.line_range)
260 		  op_index = ((op_index + adj_opcode / lh.line_range)
263 	      line += lh.line_base + (adj_opcode % lh.line_range);
265 	      if (!add_line_info (table, address, op_index, filename,
268 	      discriminator = 0;
269 	      if (address < low_pc)
270 		low_pc = address;
271 	      if (address > high_pc)
272 		high_pc = address;
274 	  else switch (op_code)
277 	      exop_len = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
279 	      line_ptr += bytes_read;
280 	      extended_op = read_1_byte (abfd, line_ptr, line_end);
281 	      line_ptr += 1;
283 	      switch (extended_op)
286 		  end_sequence = 1;
287 		  if (!add_line_info (table, address, op_index, filename, line,
290 		  discriminator = 0;
291 		  if (address < low_pc)
292 		    low_pc = address;
293 		  if (address > high_pc)
294 		    high_pc = address;
295 		  if (!arange_add (unit, &unit->arange, low_pc, high_pc))
299 		  address = read_address (unit, line_ptr, line_end);
300 		  op_index = 0;
301 		  line_ptr += unit->addr_size;
304 		  cur_file = read_string (abfd, line_ptr, line_end, &bytes_read);
305 		  line_ptr += bytes_read;
306 		  if ((table->num_files % FILE_ALLOC_CHUNK) == 0)
308 		      struct fileinfo *tmp;
310 		      amt = table->num_files + FILE_ALLOC_CHUNK;
311 		      amt *= sizeof (struct fileinfo);
312 		      tmp = (struct fileinfo *) bfd_realloc (table->files, amt);
313 		      if (tmp == NULL)
315 		      table->files = tmp;
317 		  table->files[table->num_files].name = cur_file;
318 		  table->files[table->num_files].dir =
321 		  line_ptr += bytes_read;
322 		  table->files[table->num_files].time =
325 		  line_ptr += bytes_read;
326 		  table->files[table->num_files].size =
329 		  line_ptr += bytes_read;
330 		  table->num_files++;
333 		  discriminator =
336 		  line_ptr += bytes_read;
339 		  line_ptr += exop_len - 1;
352 	      if (!add_line_info (table, address, op_index,
355 	      discriminator = 0;
356 	      if (address < low_pc)
357 		low_pc = address;
358 	      if (address > high_pc)
359 		high_pc = address;
362 	      if (lh.maximum_ops_per_insn == 1)
363 		address += (lh.minimum_instruction_length
369 		  bfd_vma adjust = _bfd_safe_read_leb128 (abfd, line_ptr,
372 		  address = ((op_index + adjust) / lh.maximum_ops_per_insn
374 		  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
376 	      line_ptr += bytes_read;
379 	      line += _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
381 	      line_ptr += bytes_read;
385 		unsigned int file;
389 		file = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
391 		line_ptr += bytes_read;
394 		filename = concat_filename (table, file);
398 	      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,
400 	      line_ptr += bytes_read;
408 	      if (lh.maximum_ops_per_insn == 1){
409 		address += (lh.minimum_instruction_length * ((255 - lh.opcode_base) / lh.line_range));
413 		  bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);
414 		  address += (lh.minimum_instruction_length
417 		  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;
421 	      address += read_2_bytes (abfd, line_ptr, line_end);
422 	      op_index = 0;
423 	      line_ptr += 2;
427 	      for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)
431 		  line_ptr += bytes_read;

====================
CWE-787___FFmpeg___libavcodec___dfa.c___144-191___184.c_vul.c
1 static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)
3     const uint8_t *frame_start = frame;
4     const uint8_t *frame_end   = frame + width * height;
5     int mask = 0x10000, bitbuf = 0;
6     int i, v, offset, count, segments;
8     segments = bytestream2_get_le16(gb);
9     while (segments--) {
10         if (bytestream2_get_bytes_left(gb) < 2)
12         if (mask == 0x10000) {
13             bitbuf = bytestream2_get_le16u(gb);
14             mask = 1;
17         if (bitbuf & mask) {
18             v = bytestream2_get_le16(gb);
19             offset = (v & 0x1FFF) << 2;
20             count = ((v >> 13) + 2) << 1;
21             if (frame - frame_start < offset || frame_end - frame < count*2 + width)
23             for (i = 0; i < count; i++) {
24                 frame[0] = frame[1] =
27                 frame += 2;
29         } else if (bitbuf & (mask << 1)) {
30             v = bytestream2_get_le16(gb)*2;
31             if (frame - frame_end < v)
33             frame += v;
35             if (frame_end - frame < width + 3)
37             frame[0] = frame[1] =
39             frame += 2;
40             frame[0] = frame[1] =
42             frame += 2;
44         mask <<= 2;

====================
CWE-125___binutils-gdb_EF12___binutils___dwarf.c___9090-9393___9290.c_vul.c
1 static int
2 process_cu_tu_index (struct dwarf_section *section, int do_display)
4   unsigned char *phdr = section->start;
5   unsigned char *limit = phdr + section->size;
6   unsigned char *phash;
7   unsigned char *pindex;
8   unsigned char *ppool;
9   unsigned int version;
10   unsigned int ncols = 0;
11   unsigned int nused;
12   unsigned int nslots;
13   unsigned int i;
20   if (phdr == NULL)
26   if (section->size < 24)
39   phash = phdr + 16;
40   pindex = phash + nslots * 8;
41   ppool = pindex + nslots * 4;
44   if (pindex < phash || ppool < phdr || (pindex == phash && nslots != 0))
64   if (ppool > limit || ppool < phdr)
71   if (version == 1)
122   else if (version == 2)
126       unsigned char *ph = phash;
128       unsigned char *poffsets = ppool + ncols * 4;
129       unsigned char *psizes = poffsets + nused * ncols * 4;
130       unsigned char *pend = psizes + nused * ncols * 4;
131       bfd_boolean is_tu_index;
132       struct cu_tu_set *this_set = NULL;
133       unsigned int row;
134       unsigned char *prow;
136       is_tu_index = strcmp (section->name, ".debug_tu_index") == 0;
140       if (poffsets < ppool || (unsigned int) ((poffsets - ppool) / 4) != ncols)
146       if (pend > limit)
153       if (do_display)
161 	  if (is_tu_index)
164 	      tu_sets = xcalloc2 (nused, sizeof (struct cu_tu_set));
165 	      this_set = tu_sets;
170 	      cu_sets = xcalloc2 (nused, sizeof (struct cu_tu_set));
171 	      this_set = cu_sets;
185       for (i = 0; i < nslots; i++)
190 	  if (row != 0)
193 	      if (row > nused)
200 	      if (!do_display)
201 		memcpy (&this_set[row - 1].signature, ph, sizeof (uint64_t));
203 	      prow = poffsets + (row - 1) * ncols * 4;
205 	      if (prow < poffsets || prow > limit)
236 	  ph += 8;

====================
CWE-787___coreutils_EF24___src___split.c___973-1019___987.c_vul.c
1 static void
2 bytes_chunk_extract (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,
3                      size_t initial_read, off_t file_size)
5   off_t start;
10   start = (k - 1) * (file_size / n);
13   if (initial_read != SIZE_MAX || start < initial_read)
15       memmove (buf, buf + start, initial_read - start);

====================
CWE-369___libtiff___libtiff___tif_jpeg.c___1576-1731___1693.c_vul.c
1 static int
2 JPEGSetupEncode(TIFF* tif)
4 	JPEGState* sp = JState(tif);
5 	TIFFDirectory *td = &tif->tif_dir;
9         if( tif->tif_dir.td_bitspersample == 12 )
18 	sp->photometric = td->td_photometric;
25 	if (td->td_planarconfig == PLANARCONFIG_CONTIG) {
26 		sp->cinfo.c.input_components = td->td_samplesperpixel;
27 		if (sp->photometric == PHOTOMETRIC_YCBCR) {
28 			if (sp->jpegcolormode == JPEGCOLORMODE_RGB) {
29 				sp->cinfo.c.in_color_space = JCS_RGB;
31 				sp->cinfo.c.in_color_space = JCS_YCbCr;
34 			if ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1)
35 				sp->cinfo.c.in_color_space = JCS_GRAYSCALE;
36 			else if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3)
37 				sp->cinfo.c.in_color_space = JCS_RGB;
38 			else if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4)
39 				sp->cinfo.c.in_color_space = JCS_CMYK;
41 				sp->cinfo.c.in_color_space = JCS_UNKNOWN;
44 		sp->cinfo.c.input_components = 1;
45 		sp->cinfo.c.in_color_space = JCS_UNKNOWN;
47 	if (!TIFFjpeg_set_defaults(sp))
50 	switch (sp->photometric) {
52 		sp->h_sampling = td->td_ycbcrsubsampling[0];
53 		sp->v_sampling = td->td_ycbcrsubsampling[1];
84 		sp->h_sampling = 1;
85 		sp->v_sampling = 1;
98 	if (td->td_bitspersample != 8 && td->td_bitspersample != 12) 
107 	sp->cinfo.c.data_precision = td->td_bitspersample;
109         sp->cinfo.c.bits_in_jsample = td->td_bitspersample;
111 	if (isTiled(tif)) {
112 		if ((td->td_tilelength % (sp->v_sampling * DCTSIZE)) != 0) {

====================
CWE-125___libjpeg-turbo___wrbmp.c___482-555___505.c_vul.c
2 jinit_write_bmp(j_decompress_ptr cinfo, boolean is_os2,
17   if (cinfo->out_color_space == JCS_GRAYSCALE) {
19   } else if (IsExtRGB(cinfo->out_color_space)) {
24   } else if (cinfo->out_color_space == JCS_RGB565 ||  

====================
CWE-190___jasper___src___libjasper___jpc___jpc_dec.c___1188-1286___1234.c_vul.c
1 static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)
3 	jpc_siz_t *siz = &ms->parms.siz;
12 	dec->xstart = siz->xoff;
13 	dec->ystart = siz->yoff;
14 	dec->xend = siz->width;
15 	dec->yend = siz->height;
16 	dec->tilewidth = siz->tilewidth;
17 	dec->tileheight = siz->tileheight;
18 	dec->tilexoff = siz->tilexoff;
19 	dec->tileyoff = siz->tileyoff;
20 	dec->numcomps = siz->numcomps;
21 	if (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {
25 	if (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {
43 	dec->image = 0;
45 	dec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);
46 	dec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);
47 	dec->numtiles = dec->numhtiles * dec->numvtiles;

====================
CWE-787___libjpeg-turbo___jdmarker.c___302-371___327.c_vul.c
1 get_sos (j_decompress_ptr cinfo)
5   int i, ci, n, c, cc;
21   cinfo->comps_in_scan = n;
25   for (i = 0; i < cinfo->num_components; i++)
26     cinfo->cur_comp_info[i] = NULL; // cinfo->cur_comp_info has length MAX_COMPS_IN_SCAN

====================
CWE-125___libtiff___tools___tiffcrop.c___951-1096___994.c_vul.c
1 static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf, 
2 					 uint32 imagelength, uint32 imagewidth, 
3                                          uint32 tw, uint32 tl,
4                                          uint16 spp, uint16 bps)
9   uint32  row, col;     /* Current row and col of image */
10   uint32  nrow, ncol;   /* Number of rows and cols in current tile */
11   uint32  row_offset, col_offset; /* Output buffer offsets */
12   tsize_t tbytes = 0, tilesize = TIFFTileSize(in);
13   tsample_t s;
15   unsigned char *srcbuffs[MAX_SAMPLES];
20   for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)
22     srcbuffs[sample] = NULL;
23     tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);
24     if (!tbuff)
32     srcbuffs[sample] = tbuff;
37   for (row = 0; row < imagelength; row += tl)
39     nrow = (row + tl > imagelength) ? imagelength - row : tl;
40     for (col = 0; col < imagewidth; col += tw)
42       for (s = 0; s < spp; s++)
44 	tbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);
45         if (tbytes < 0  && !ignore)
66       if (col + tw > imagewidth)
67         ncol = imagewidth - col;
69         ncol = tw;
71       row_offset = row * (((imagewidth * spp * bps) + 7) / 8);
72       col_offset = ((col * spp * bps) + 7) / 8;
73       bufp = obuf + row_offset + col_offset;
75       if ((bps % 8) == 0)
77         if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, imagewidth,

====================
CWE-125___libjpeg-turbo___rdbmp.c___124-151___145.c_vul.c
1 get_8bit_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
4   bmp_source_ptr source = (bmp_source_ptr) sinfo;
5   register JSAMPARRAY colormap = source->colormap;
6   JSAMPARRAY image_ptr;
9   register JDIMENSION col;
12   source->source_row--;
13   image_ptr = (*cinfo->mem->access_virt_sarray)
18   inptr = image_ptr[0];
19   outptr = source->pub.buffer[0];
20   for (col = cinfo->image_width; col > 0; col--) {
21     t = GETJSAMPLE(*inptr++);
22     *outptr++ = colormap[0][t]; /* colormap[x] has size cmaplen */
23     *outptr++ = colormap[1][t]; /* colormap[x] has size cmaplen */
24     *outptr++ = colormap[2][t]; /* colormap[x] has size cmaplen */

====================
CWE-787___coreutils_EF23___src___shred.c___280-299___293.c_vul.c
1 static void
2 fillpattern (int type, unsigned char *r, size_t size)
4   size_t i;
5   unsigned int bits = type & 0xfff;
7   bits |= bits << 12;
8   r[0] = (bits >> 4) & 255;
9   r[1] = (bits >> 8) & 255;
10   r[2] = bits & 255;
11   for (i = 3; i < size / 2; i *= 2)
12     memcpy (r + i, r, i);

====================
CWE-125___libxml2___parser.c___3893-4116___4079.c_vul.c
1 static xmlChar *
2 xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
6     size_t len = 0;
8     int c, l, in_space = 0;
10     xmlEntityPtr ent;
12     if (NXT(0) == '"') {
13 	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
14 	limit = '"';
16     } else if (NXT(0) == '\'') {
17 	limit = '\'';
18 	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
28     buf_size = XML_PARSER_BUFFER_SIZE;
29     buf = (xmlChar *) xmlMallocAtomic(buf_size);
30     if (buf == NULL) goto mem_error;
35     c = CUR_CHAR(l);
36     while (((NXT(0) != limit) && /* checked */
43         if ((len > XML_MAX_TEXT_LENGTH) &&
49 	if (c == 0) break;
50 	if (c == '&') {
51 	    in_space = 0;
52 	    if (NXT(1) == '#') {
53 		int val = xmlParseCharRef(ctxt);
55 		if (val == '&') {
56 		    if (ctxt->replaceEntities) {
60 			buf[len++] = '&';
69 			buf[len++] = '&';
70 			buf[len++] = '#';
71 			buf[len++] = '3';
72 			buf[len++] = '8';
73 			buf[len++] = ';';
75 		} else if (val != 0) {
79 		    len += xmlCopyChar(0, &buf[len], val);
82 		ent = xmlParseEntityRef(ctxt);
83 		ctxt->nbentities++;
84 		if (ent != NULL)
85 		    ctxt->nbentities += ent->owner;
86 		if ((ent != NULL) &&
91 		    if ((ctxt->replaceEntities == 0) &&
93 			buf[len++] = '&';
94 			buf[len++] = '#';
95 			buf[len++] = '3';
96 			buf[len++] = '8';
97 			buf[len++] = ';';
99 			buf[len++] = ent->content[0];
101 		} else if ((ent != NULL) &&
103 		    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
104 			rep = xmlStringDecodeEntities(ctxt, ent->content,
107 			if (rep != NULL) {
108 			    current = rep;
109 			    while (*current != 0) { /* non input consuming */
110                                 if ((*current == 0xD) || (*current == 0xA) ||
112                                     buf[len++] = 0x20;
113                                     current++;
115                                     buf[len++] = *current++;
127 			if (ent->content != NULL)
128 			    buf[len++] = ent->content[0];
130 		} else if (ent != NULL) {
131 		    int i = xmlStrlen(ent->name);
132 		    const xmlChar *cur = ent->name;
151 		    buf[len++] = '&';
155 		    for (;i > 0;i--)
156 			buf[len++] = *cur++;
157 		    buf[len++] = ';';
161 	    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
162 	        if ((len != 0) || (!normalize)) {
169 		    in_space = 1;
172 	        in_space = 0;
181 	c = CUR_CHAR(l);
183     if (ctxt->instate == XML_PARSER_EOF)
186     if ((in_space) && (normalize)) {
187         while (buf[len - 1] == 0x20) len--;

====================
CWE-476___libjpeg-turbo___jquant1.c___518-563___536.c_vul.c
1 quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
2                      JSAMPARRAY output_buf, int num_rows)
13   int row;
15   JDIMENSION width = cinfo->output_width;
17   for (row = 0; row < num_rows; row++) {
19     jzero_far((void *) output_buf[row], (size_t) (width * sizeof(JSAMPLE)));

====================
CWE-125___coreutils_EF25___src___pr.c___1190-1298___1236.c_vul.c
1 static void
2 init_parameters (int number_of_files)
20   if (number_of_files == 0)
21     parallel_files = false;
23   if (parallel_files)
24     columns = number_of_files;
32   if (columns > 1)
34       if (!use_col_separator)
47       else if (!join_lines && *col_sep_string == '\t') // In this case, col_sep_length must be 1.

====================
